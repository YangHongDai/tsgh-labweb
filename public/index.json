
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"authors":["戴揚紘"],"categories":null,"content":"我是一位專注於腫瘤學與免疫治療的放射腫瘤科醫師，致力於透過創新技術和研究推進癌症治療的發展。 除了體外放射治療的研究，目前我正在深入研究標靶核種藥物(targeted radionuclide)的潛力，特別是針對 Lutetium-177-prostate specific membrane antigen(PSMA)治療。我也在探討這種治療是否能刺激免疫系統對抗癌細胞的潛力。我的研究不僅在優化治療策略，還希望透過大數據分析來探討各種癌症治療模式與免疫機制間的關係。\n","date":1734825600,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1734825600,"objectID":"c7ffabeeb454c3171c71da610a5ca400","permalink":"http://localhost:56953/author/yang-hong-dai-%E6%88%B4%E6%8F%9A%E7%B4%98/","publishdate":"2024-12-22T00:00:00Z","relpermalink":"/author/yang-hong-dai-%E6%88%B4%E6%8F%9A%E7%B4%98/","section":"authors","summary":"我是一位專注於腫瘤學與免疫治療的放射腫瘤科醫師，致力於透過創新技術和研究推進癌症治療的發展。 除了體外放射治療的研究，目前我正在深入研究標靶核種藥物(targeted radionuclide)的潛力，特別是針對 Lutetium-177-prostate specific membrane antigen(PSMA)治療。我也在探討這種治療是否能刺激免疫系統對抗癌細胞的潛力。我的研究不僅在優化治療策略，還希望透過大數據分析來探討各種癌症治療模式與免疫機制間的關係。\n","tags":null,"title":"Yang-Hong Dai 戴揚紘","type":"authors"},{"authors":null,"categories":null,"content":"我是一位腎臟科醫師，專注於腎臟病學的計算工具開發。我的研究興趣包括探索急性腎損傷、腎絲球腎炎以及慢性腎病中的蛋白質交互網絡。目前，我在台灣國立陽明交通大學進行系統生物學的研究，致力於推進多組學的計算應用，以增進對腎臟相關疾病的理解與治療。\n","date":1732838400,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1732838400,"objectID":"91e53fa29b6eff1616a7e31b080c25ed","permalink":"http://localhost:56953/author/ding-jie-lee-%E6%9D%8E%E5%AE%9A%E9%A0%A1/","publishdate":"2024-11-29T00:00:00Z","relpermalink":"/author/ding-jie-lee-%E6%9D%8E%E5%AE%9A%E9%A0%A1/","section":"authors","summary":"我是一位腎臟科醫師，專注於腎臟病學的計算工具開發。我的研究興趣包括探索急性腎損傷、腎絲球腎炎以及慢性腎病中的蛋白質交互網絡。目前，我在台灣國立陽明交通大學進行系統生物學的研究，致力於推進多組學的計算應用，以增進對腎臟相關疾病的理解與治療。\n","tags":null,"title":"Ding-Jie Lee 李定頡","type":"authors"},{"authors":["沈伯鍵"],"categories":null,"content":"我是放射腫瘤科醫師，在臨床工作之餘，專注研究透過資料科學分析臨床數據，推動放射治療的個人化發展。我的研究核心在於結合影像組學，探討如何預測患者的放療副作用及預後。期望在現行治療指引的基礎上，進一步針對個別患者的風險，量身優化放射治療的劑量或照野，提升治療的精準性與效果。\n","date":1721520000,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1721520000,"objectID":"a8ab0b7c08c1953d0976efa63fe615e1","permalink":"http://localhost:56953/author/po-chien-shen-%E6%B2%88%E4%BC%AF%E9%8D%B5/","publishdate":"2024-07-21T00:00:00Z","relpermalink":"/author/po-chien-shen-%E6%B2%88%E4%BC%AF%E9%8D%B5/","section":"authors","summary":"我是放射腫瘤科醫師，在臨床工作之餘，專注研究透過資料科學分析臨床數據，推動放射治療的個人化發展。我的研究核心在於結合影像組學，探討如何預測患者的放療副作用及預後。期望在現行治療指引的基礎上，進一步針對個別患者的風險，量身優化放射治療的劑量或照野，提升治療的精準性與效果。\n","tags":null,"title":"Po-Chien Shen 沈伯鍵","type":"authors"},{"authors":["戴揚紘",""],"categories":["單細胞定序"],"content":"Quick look 單細胞定序已經在近年成為各大實驗室不可或缺的關鍵技術之一，讓我們從過去將組織混雜在一起的bulk RNA-seq精細化到單細胞的解析度，也讓我們可以針對一顆腫瘤做細部的分類，、甚至推測細胞分化的路徑，今天我們要讀的文章算是比較舊的nature protocol review article (2018)，但針對我們想要做單細胞定序分析的人來說是很推薦的入門讀物之一。\nscRNA-seq 席捲科學界 scRNA-seq 顯著增加了我們對組織、器官和細胞之間複雜交互作用的了解。隨著自動化處理流程的演進與微流體（microfluidic）技術的發明，scRNA-seq的延展性（scalability）才能大幅的提升。\n過往的實驗設計通常是基於某一個假說或是假設（hypothesis），但若是這個假設錯誤或是不成立，就要花額外的時間從另外一個假設著手，這種hypothesis-driven的方式比較費時。自從有了scRNA-seq後，我們可以一探每一顆細胞的全基因組、蛋白質組甚至是表觀遺傳基因組，從hypothesis-driven過渡到data-driven的實驗設計，大幅降低bulk情形下帶來的biased analysis。\n但因為scRNA-seq的研究太專一化，不同的樣本有截然不同的處理步驟，而數據分析也依據不同的需求而有所不同，因此在研究設計上無法將一套準則套用在所有的實驗上，但也因為這個限制，近年有層出不窮的protocols、tools或是網頁工具出現，試圖來優化及改善整條從樣本製備到數據分析的過程 (圖一)。\n圖一 單細胞定序流程 樣本製備 樣本本身的品質對整個scRNA-seq的成敗是最關鍵的。在過去，大部分都要求使用新鮮的活細胞，但實務上如果要在取出每個腫瘤後立即分解成單細胞懸浮液其實頗具挑戰性，因此目前有不少protocol是允許使用固定後的腫瘤或細胞，也允許冷凍後仍完整的細胞核RNA，一來可以讓我們可以好好計畫樣本製備的流程，二來也不影響後續數據的分析，可以參考目前10X Genomics釋出的GEM-X FLEX protocol。\n其他一些注意事項如下：\n使用無核酸酶試劑和耗材。 減少樣本溶液的轉移與離心操作以避免細胞損傷。 篩選較大的細胞團塊和細胞死亡後的雜質與碎片。最好在30分鐘內用酵素分解細胞團塊，避免團塊聚集。 適合的懸浮液緩衝液組成：無鈣、鎂的PBS。含牛血清白蛋白以減少聚集。比較敏感的細胞、幹細胞可能需要其他的緩衝液來增加存活。 細胞懸浮液的製備 血液樣本可以用密度梯度離心（density centrifugation）的方式來分離，例如Ficoll-Paque 或 Histopaque-1077 的方式來捕捉特定單細胞，但是實體組織必須要利用機械（mechanical）或是酵素來分解組織塊來取得單細胞懸浮液。\n機械方式：可以用剪刀或是剃刀將組織切成小碎塊，通常約大小 1mm x 1mm x 1mm，才能增加與酵素接觸的表面積。 酵素分解：切成小塊後，要接著用酵素做分解，針對不同的組織有不同的酵素組合，可以參考圖二。 圖二 不同組織所建議的分解酵素 值得注意的是，在樣本製備的過程中，活的細胞有可能會因為過程中遭遇的stress而導致某些反應性基因的表現改變，因此過程中需要盡可能地減少stress。\n另外就是針對像神經元所在的組織中，神經元彼此之間交聯的程度有可能會導致細胞分離的過程不完全。針對這個問題可以考慮破壞細胞膜的方式來取得完整的細胞核做分析，而用細胞核內部的RNA做分析雖然會降低每顆細胞最終的解析度，但是已能提供足夠訊息來解析細胞態 （cell type deconvolution）。\n單細胞捕獲 做單細胞定序前，當然需要想辦法捕捉到單顆細胞，而目前有許多不同的方式：\nMicrodissection Pipetting Fluorescence-activated cell sorting (FACS) Microfluidics 後面兩個技術為high-throughput，可以有效率的捕獲大量的單細胞。FACS 可以將帶有特定螢光的細胞挑出來，並收集到微孔板（microtiter plate）中；而microfluidics 是利用integrated fluidic circuits (IFC)、油滴或是奈米板（nanowell）、來同時收集及處理細胞，減少試劑的使用。有些時候為了降低背景噪音及優化定序的表現，可以在使用microfluidic 系統前先用FACS或MACS（magnetic-activated cell sorting）來移除死細胞或是雜質。\n樣本大小與組成 雖然取得unbiased 細胞組成（盡可能捕捉到全部）很重要，但有時候太大或太小的細胞反而會卡在微流體系統或是被FACS忽略，因此有時候研究反而會針對某些特定的細胞群體，如免疫細胞去做富集，或是去掉血球細胞（CD45+）。\nFACS的技術可以藉由螢光強度或細胞大小（FACS可以提供的訊息）來對細胞做編列（indexing），讓我們可以知道細胞在sorting時的位置與螢光強度，讓後續做transcriptomic profiling 時可以追蹤細胞標記。\n除了FACS系統，CITE-seq(圖三)利用oligonucleotide標記的抗體辨識細胞表面的記號（epitope），這個抗體專一性oligonucleotide sequence 接上了一條poly(A) tail 及一段特殊條碼，讓我們在scRNA-seq library construction時可以追蹤epitope。\n圖三 CITE-seq 流程 細胞數量 另外實驗的細胞數量需要多少也是很重要的參數，須要考慮樣本的異質性與感興趣細胞的出現頻率，一般來說，有兩種情況需要較多的細胞：\n樣本異質性高: 所以需要較多的細胞數量來解構所有的次群體。 感興趣的細胞很罕見: 所以需要較多的細胞數量來增加他出現的次數。 針對同質性高的樣本並不是說細胞數量可以減到很少，因為足夠的細胞數量才能增加統計效力。\n目前也有工具可以幫我們估計我們需要多少細胞數量，如Satija 教授開發的網路工具howmanycell。\n針對目前GEM-X FLEX 提供的protocol，因為是基於探針來偵測基因的表現，所以最多只能提供50萬個細胞的探針，更多的細胞會被浪費掉，所以在實際操作的時候需要詳細閱讀protocol。\n樣本保存 過去大部分scRNA-seq的步驟都要求取得新鮮的活細胞來做定序，但是取得腫瘤後立即處理樣本其實頗具挑戰性，也很吃人力和時間成本，如果又沒有FACS的專門的儀器，會變得相當尷尬。\n此外，雖然可以在不同天處理腫瘤，但是我們都知道這樣會引入Batch effect，因此同一天處理樣本是最理想的狀況，想當然底下的研究助理會想哭吧…。\n有鑑於此，不少的冷凍保存（cryopreservation）技術也開發出來，讓我們可以使用冷凍後的樣本做處理。而研究顯示，在-80度或是液態氮保存的樣本在解凍後，仍然保有完整的RNA與基因表現，但目前仍不建議對樣本進行反覆的冷凍與解凍。\n而針對急速冷凍（snap-freeze）的樣本，因為冰晶（crystal）會破壞細胞膜，多數細胞並不完整，只能利用nuclei 來取得scRNA-seq。\n單細胞定序 單細胞定序主要有四個步驟：\nRNA分子的捕獲（capture） 放大（transcriptome amplification） 建立定序庫（sequencing library） 定序（sequencing） RNA molecule capture, reverse transcription and transcriptomics amplification for sequencing library construction 大多的單細胞的RNA分子捕獲利用poly(A)-tailed RNA來辨識mRNA，針對total RNA 也有其他特殊的方式，但比較少用。 所以我們只要設計一段poly(T) oligonucleotide就可以收集所有mRNA，但是必然會忽略掉數量也很多的rRNA與tRNA，在捕獲之後，RNA片段會被反轉綠成cDNA，接續進行放大與定序庫的建立。 在設計oligonucleotide的時候，會插入專一的單細胞編碼（single cell barcode），讓後續在定序時，可以做pooling與multiplex。 除了cell barcode外，還會插入約12的核苷酸的unique molecular identifier (UMI)，用來去除後續cDNA擴增後帶來的擴增噪音，是單細胞分析裡面很關鍵的技術。關於UMI如何作用，可以參考這個網站。\n而針對cDNA的擴增，基本上有兩種方式：\nPCR：所需步驟較少，但是對RNA的定量會引入較多的擴增偏差。 In vitro transcription （IVT）：利用線性擴增，因此引入的擴增偏差較少，但需要的後續步驟較多。 圖四為各種平台的技術概況： 圖四 單細胞平台技術概況 Full length vs 3’ or 5’ transcript sequencing 轉錄的過程可以分為全長（full length）或是針對5’/3’端來做定量（digital counting），這兩個方式的差別在於：\nFull length: mRNA的整段都可以解碼出來，因此適合用於須要了解splice variant 或是 alternative splicing的研究。T與B細胞的受體genotype 也可以藉由full length sequencing 來還原。 然而這種技術因為並沒有在處理初期插入UMI，所以並不能做indexing，因此實驗成本會較高。 3\u0026#39;/5\u0026#39; sequencing: 因為PCR先天的限制，在mRNA的尾端無法完整進行下去，因此會喪失掉尾端的訊息，但如果只在乎基因的表現量，這樣的限制並不會影響實驗的目的。此外，因為在處理的過程中可以加入cell barcodes，所以有利於indexing與multiplex，減少成本。 scRNA-seq methodology 這邊僅針對目前最常用的微流體系統來做描述，想了解其他方法，如microtiter plate-based 或split-pool barcoding-based的可以另外搜尋文獻。\nMicrofluidic system-based approaches 微流體系統的優勢在於可以高通量的針對單細胞做處理，具有很高的技術延展性（scalability），彌補microtiter-based 方法的不足，同時增加了cDNA的產量。\n最初用來做scRNA-seq的微流體系統使用拋棄式微流體晶片，完成單細胞裂解、核酸純化、反轉錄作用和擴增放大流程，最後將單細胞之終產物存放至獨立槽中，進行後續分析，Fluidigm C1就是使用這種方式。但早期的晶片只有96個細胞捕獲位點，後來新的技術（C1 HT-IFC）才增加到了800個位點，並允許早期編碼（early-indexing），讓細胞可以混合在一起做後續分析，大幅降低了成本。\n為了進一步增加捕獲的細胞數量，微流體技術發展為更具擴展性的開放式奈米孔系統。例如，STRT-seq-2i運用具有9600個位點的奈米孔平台，通過限制性稀釋或特殊的FACS技術排序並加載細胞。此外，奈米孔陣列的形式允許我們透過影像來觀察一個孔裡面是否有出現兩個以上的細胞（doublet）。\n另一個奈米孔技術為Seq-Well，可在捕獲高達86000個細胞並進行反應，原理是將帶有條碼的珠子先裝到奈米孔中，然後細胞通過限制性稀釋進入捕獲位點。隨後陣列被密封以進行細胞裂解和RNA的捕獲，最後將固定的RNA分子集中製備3’端library。然而，儘管這種技術可以通過顯微鏡監測細胞，但帶有條碼的珠子因為隨機分佈的特性使得影像的整合困 …","date":1734825600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1734825600,"objectID":"58db7057e13c9445b6be2b951cd20eac","permalink":"http://localhost:56953/post/scrna_guide/","publishdate":"2024-12-22T00:00:00Z","relpermalink":"/post/scrna_guide/","section":"post","summary":"","tags":["scRNA-seq","data science"],"title":"初探單細胞定序","type":"post"},{"authors":["戴揚紘",""],"categories":["數據科學"],"content":"Quick look 支持向量機（SVM）是一種強大的監督式學習模型，廣泛應用於分類和回歸分析中。SVM 以其獨特的數學基礎和幾何直觀性，在高維數據空間中具有出色的性能，尤其適合處理少量數據和非線性問題。\n支持向量機的基本原理 SVM 的核心目標是找到一條分隔超平面（hyperplane），以最大化兩類數據點之間的間隔（margin）。以下是其運作的核心步驟：\n分隔超平面 超平面是一個 d-1 維的空間，分隔 d 維特徵空間中的數據點。對於二分類問題，SVM 旨在找到一個最優超平面，使得兩類數據點之間的邊界最大化。數學表示為：\n最大間隔原理 SVM 以「最大化分類間隔」為優化目標。目標函數為：\n硬邊界（Hard Margin）：數據點完全線性可分的情況，超平面將所有點正確分類。 軟邊界（Soft Margin）：允許少量錯誤分類的情況，引入松弛變量（slack variable） ξ ξ，以平衡分類錯誤和間隔最大化。\n核函數（Kernel Function） SVM 支持非線性數據的分類，通過核函數將數據從低維空間映射到高維空間，使其在高維空間中線性可分。 常見的核函數包括： 支持向量機的優缺點\n優點 高效處理高維數據 SVM 在高維空間中表現良好，並能有效處理高維度的特徵。 核函數允許其在非線性數據中找到最佳的分類邊界。 數學理論穩健 以凸優化問題為基礎，保證了全局最優解的存在。 適合小樣本學習 SVM 能在小數據集上表現出色，因為它的訓練過程只依賴於支持向量，而非所有數據點。 良好的泛化能力 最大間隔原理有效降低了模型的過擬合風險。 缺點 對超參數敏感 核函數的選擇、參數 γ γ 和 C C 的設置對模型性能有顯著影響，調參較為耗時。 計算成本高 當數據量較大時，計算支持向量的過程需要大量的內存和時間。 隨著數據量增大，SVM 的訓練速度可能急劇下降。 難以解釋 在高維空間中，分類邊界的可視化和解釋較為困難。 對噪音敏感 SVM 在處理存在噪音的數據時，可能表現不佳，尤其是在軟邊界中，噪音數據可能影響超平面的選擇。 3. SVM 的應用場景\n(1) 分類任務 文本分類：垃圾郵件過濾、情感分析等。 圖像分類：目標檢測、人臉識別。 醫療診斷：癌症預測、基因表達分類。 (2) 回歸任務 SVM 可應用於回歸分析（SVR, Support Vector Regression），用於預測連續值。 如房價預測、股票市場分析。 (3) 異常檢測 在監測數據中識別異常點，如網絡入侵檢測、機器故障檢測。 4. SVM 的未來發展與改進方向\n處理大規模數據 隨著數據量的增加，開發分布式和並行化 SVM 訓練算法成為重點。 如使用梯度下降法來替代二次規劃，降低計算成本。 結合深度學習 將 SVM 作為深度神經網絡的輸出層，結合深度學習的特徵提取能力，提高分類性能。 更靈活的核函數 開發自適應核函數，使其能自動選擇適合當前數據分布的核方法。\n","date":1734825600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1734825600,"objectID":"039a5aded1ea3595932b885cc9d1a1b6","permalink":"http://localhost:56953/post/svm/","publishdate":"2024-12-22T00:00:00Z","relpermalink":"/post/svm/","section":"post","summary":"","tags":["Support vector machine","data science"],"title":"數據科學聊聊：支持向量機（Support vector machine）","type":"post"},{"authors":["戴揚紘",""],"categories":["計算生物學"],"content":"Quick look 分子表示法（molecular representation）在計算化學中扮演重要的角色，它使化學家和數據科學家能夠將複雜的化學結構轉換成機器可理解的形式，用於數據存儲和計算分析。這些表示法在格式、易用性和應用場景上存在顯著的差異，每種表示法在特定類型的分析中具有其獨特的優勢和局限性，透過建構圖神經網路（Graph neural network）來預測分子的特性，這些表示法的差異會更為顯著。\n本篇筆記出自於美國麻省理工學院的計算生物學課程MLCB24。課程影片請看這裡。\n常見的分子表示法 SMILES (簡化分子輸入線性表示系統) SMARTS（SMILES 任意目標規範） InChI（國際化學標識符） Molecular graph (分子圖) 接下來會根據每一種表示法做介紹：\nSMILES SMILES（Simplified Molecular Input Line Entry System）是一種基於字串的分子表示法，最初由美國環保署（EPA）開發，用於以緊密相連的線性格式捕捉分子的結構。目前為化學資訊學中最廣泛使用的小分子表示法之一。\n格式 例如，乙醇的 SMILES 表示為 CCO（省略氫原子）。字母和數字表示原子與鍵類型（單鍵、雙鍵等），括號則用來標示分支結構。\n優點 SMILES 具有高度壓縮性（compact），容易被大多數化學資訊軟體讀取，適合用於資料庫存儲。\n限制 合成混淆：SMILES 字串靈活性高，容易生成，但這種靈活性導致許多語法有效的 SMILES 字串可能無法解碼成實際分子。 立體化學：雖然 SMILES 可以包含立體化學資訊，但通常在實務上會被省略，當分子功能取決於立體資訊時，會導致問題產生。\nSMARTS（SMILES 任意目標規範） SMARTS 是根據 SMILES 來擴展的表示法，允許在 SMILES 字串中進行模式匹配來識別特定的分子子結構。\n應用 SMARTS 對於化學資訊學中的子結構搜索特別有用，例如識別芳香環或其他分子功能基團。\n格式 例如，芳香環可以用c1cccccc1來表示。\n限制 儘管 SMARTS 在子結構搜索中功能強大，但比 SMILES 更複雜，需要對化學模式有更深入的理解才能有效使用。\nSELFIES（自引用嵌入字串） SELFIES 是一種較新的表示法，主要在克服 SMILES 的一些限制。它更像是一種分子編程語言，允許完整解構字串，系統化生成分子，\n關鍵優勢 可以很好的耐受錯誤，所有的SELFIES字串都可以解構成某特定分子，不會導致訊息的喪失，有利於機器學習。\n格式 例如，苯環可以表示成：C1=CC=CC=C1。\n限制 SELFIES 雖然創新，但較難閱讀，且需進一步改進以確保化學空間中的採樣沒有偏誤。\nInChI（國際化學標識符） InChI 是一種IUPAC開發的標準化分子表示法，保證每個分子與其 InChI 字串一一對應。包含多層的分子特徵，如連結性、價電子、空間化學與異構物等。\n應用 InChI 在資料庫搜索和比較中特別有價值，因為它允許直接進行分子比較，避免了因不同 SMILES 表示法導致的多餘訊息。因為SMILE並沒有賦予分子獨特性，因此需要電腦解讀，增加計算負擔。\n關鍵優勢 標準化的表示法，每一個表示法都對應到單一獨特的分子式。\n格式 例如，乙醇可以表示成：1S/C2H6)/c1-2-3/h3H,2H2,1H3。\n限制 InChI 的複雜性使其難以閱讀和解釋。由於簡潔性，許多人更偏好用 SMILES 進行可視化。目前有方法將SMILES表達法InChI化，藉此增加InChI的可讀性。\n分子圖 分子圖是一種基於圖形的分子表示法，其中原子是頂點，鍵是邊。這種表示法捕捉了分子的所有信息，包括原子類型、鍵類型，甚至是立體化學。\n優點 分子圖全面地提供分子結構的完整描述，較為直覺，尤其適用於基於圖的機器學習中的計算分析。\n限制 與基於字串的格式不同，分子圖不如 SMILES 那麼緊密，也不適合快速搜索資料庫。分子圖更適合用於計算應用和視覺化，而非數據儲存。\n分子表示法比較 圖一顯示不同分子表示法的總結。 圖一 分子表示法比較 SMILES 表示法 原子與鍵 一般原子：在 SMILES 字串中，每個原子由其化學符號表示。大多數原子使用單個大寫字母表示（例如，C 表示碳，O 表示氧）。一些原子需要兩個字母的組合（如 Na 表示鈉，Cl 表示氯）。 芳香原子：在 SMILES 中，小寫字母表示芳香化合物中的原子。例如，小寫的 c 表示芳香碳，常見於苯環中。 鍵：單鍵通常為簡化省略，但也可使用單個破折號 - 明確表示。雙鍵用等號 = 表示，三鍵用井號 # 表示。芳香鍵通常省略，因為小寫原子符號已隱含芳香性。分子組件的分離：句點 . 用於表示分子中不連接的部分，例如鹽或離子對。例：Na.Cl 表示氯化鈉。 鏈與分支 線性鏈：簡單的原子鏈以直線順序表示。例如，乙醇的 SMILES 表示為 CCO，表示碳-碳-氧鏈。 分支：SMILES 使用括號表示從主鏈分支的結構。主鏈從括號前的原子開始繼續。例如，異丙醇 (2-propanol or isopropanol)的 SMILES 表示為 CC(O)C，其中 (O) 表示OH-分支。 其他例子：\nCC(=O)C: 2-Propanone\nCC(CC)C: 2_Methylbutane\nCC(C)CC(=O): 2-Methylbutanal\nc1c(N)(=O)=O)cccc1: Nitrobenzene\nCC(C)(C)CC: 2,2-Dimethylbutane\n環與環狀結構 環閉合：SMILES 使用數字標記環閉合。例如，苯的表示為 c1ccccc1，其中 1 表示第一和最後的碳原子相連以完成環。相同的數字表示開環與閉環的原子位置。鍵的類型著記在原子之後，但在數字之前。 多重環：對於更複雜的環系統，使用額外的數字來表示分子內的每個環。例如，萘的 SMILES 表示為 c1ccc2ccccc2c1，其中 1 和 2 標記了兩個融合的環 (圖二)。 圖二 萘 (Naphthalene)的SMILES表示法 電荷 電荷表示：SMILES 使用卷曲括號 {} 和加號 + 或減號 - 表示原子的電荷。\n模稜兩可的名稱 若是比較容易讓人誤解的標示方法，用大括號 [] 來區分，如Sc沒有框起來的話表示Sulfur與aromatic carbon，而[Sc]則表示Scandium。\nMorgan 指紋：機器學習中的分子結構編碼 Morgan 指紋（也稱為環狀指紋）是一種強大的工具，可將分子結構轉換為固定長度的二進制向量，使其非常適合於機器學習應用。與需要詳細結構數據的完整分子圖不同，Morgan 指紋提供了一種計算效率更高的表示方式，捕捉每個原子周圍的結構特徵並以易於輸入機器學習模型的格式儲存。\nMorgan 指紋的目的 定量結構-活性關係（QSAR）建模：例如，預測分子的疏水性、溶解度或潛在生物活性。 高通量篩選：在藥物發現中，用於快速篩選分子。 主要優勢 固定長度表示：每個分子無論大小都表示為特定長度的向量，與許多機器學習模型直接兼容。 結構資訊封裝：通過編碼以原子為中心的子結構（達到指定半徑），捕捉局部化學環境。 計算效率：這種表示方式比生成完整分子圖更快，並且生成的指紋可快速用於機器學習。 Morgan 如何運作？ 生成 Morgan 指紋涉及一系列步驟，這些步驟專注於分子中的每個原子，並檢查其在指定半徑內的局部結構 (圖三)。\n以原子為中心的編碼： 每個原子作為中心點，檢查其周圍的子結構。這些子結構的細節取決於設定的半徑。 定義半徑：\n半徑 0：僅編碼原子本身。\n半徑 1：編碼原子及其鄰近原子。\n半徑 2：編碼原子、其鄰近原子及這些鄰近原子的鄰居。\n通常，使用半徑 2 即可捕捉足夠的細節，而不會導致向量過於龐大。\n將子結構映射到比特 (bit) 位置：每個環狀子結構都被編碼為一個二進制向量（bit string），其中特定特徵（例如原子、鍵、環）的存在記錄為1，缺失記錄為0。半徑決定了圍繞中心原子的原子層數（例如，半徑為2時包括距離中心原子兩鍵以內的原子和鍵）。\n子結構碰撞：子結構被哈希(hash)轉換為固定長度的指紋（例如1024位），這可能導致哈希碰撞，即多個子結構可能映射到相同的位。可以考慮增加長度來解決。\n圖三 Morgan fingerprint Morgan 指紋生成範例 第一步：從分子內的某原子開始。 第二步：根據特定的半徑來建構子結構。 第三步：使用Hash table來將子結構轉換成獨特的比特編號。 第四步：針對每一個原子完成以上步驟，產生一個二元分子指紋，表示整個分子。 以乙醇（CCO）為例 每個碳和氧原子作為中心點，評估其半徑 2 內的子結構。\n這將產生以下信息：\n原子 1：第一個碳及其鄰居（第二個碳和氧）。 原子 2：第二個碳及其鄰居（第一個碳和氧）。 原子 3：氧及其鄰近的碳。 每個原子和子結構會映射到指紋中，形成唯一表示乙醇結構的比特向量。 Morgan 指紋的優點 對結構改變非常敏感，結構的些微修飾都可以被捕捉。 效率高。 廣泛使用於常見化學資訊學的工具中，如RDKit，也常用在視覺篩選與相似性搜索中。 半徑與比特向量長度的平衡 半徑增加的影響：\n半徑越大，捕捉的子結構越詳細，但需要更大的向量以避免碰撞。 半徑 2 提供了適度的細節，廣泛用於化學資訊學。 半徑 3 或更大通常僅在需要非常細粒度結構細節時使用，但會顯著增加計算需求和複雜性。 向量長度 常用長度為 1024 或 2048 比特。更大的向量幫助減少哈希碰撞，但在數據集較小時可能導致稀疏性問題。\n在機器學習中的解釋與應用 Morgan 指紋將複雜的分子結構轉換為向量空間表示，其中具有相似拓撲特徵的分子具有相似的指紋。結果向量可用於以下機器學習模型：\n隨機森林：適合特徵豐富的數據集，向量直接表示分子特徵。 多層感知機（MLP）：能有效處理 Morgan 指紋，學習數據中的非線性模式。 其他演算法：包括支持向量機（SVM）和邏輯回歸在內的任何處理二進制或數值向量的演算法均可使用 Morgan 指紋。 限制與考量 不可逆：指紋無法反向解碼為原始分子。 碰撞問題：不同的分子結構可能映射到相同的比特位置，尤其是在較小的比特向量或大分子時。 不適用於大生物分子：對於非常大的生物分子（如蛋白質），Morgan 指紋可能不適用，因為結構的複雜性超出了其表達能力。 分子圖：化學結構的進階表示 分子圖是一種靈活且精細的方式，能夠以數學形式表示分子，特別是在指紋無法捕捉足夠結構細節時尤為有用。與比特向量指紋不同，分子圖提供了分子結構的直接映射，將每個原子作為節點，每條鍵作為邊。這種基於結構的表示允許更高的特異性和數據的豐富性，使其成為圖神經網絡（Graph Neural Networks, GNNs）的理想輸入，尤其適用於需要深入關係建模的任務，例如定量結構-活性關係（QSAR）和基於結構的藥物設計。\n分子圖的結構\n節點與邊：在分子圖中，每個節點表示一個原子，每條邊表示一條化學鍵。這種結構捕捉了分子內的原子類型及鍵類型（單鍵、雙鍵、三鍵或芳香鍵），能夠詳細描述化學關係。 標籤與特徵： 節點標籤：每個節點可以攜帶標籤或類型（例如，碳用 C 表示，氮用 N 表示），以區分不同的原子類型。 邊標籤：邊可以標示鍵的類型（如單鍵、雙鍵、三鍵等）。這在分子圖中尤為重要，因為鍵類型對分子的化學行為和特性有著重要影響。 有向與無向圖： 在大多數情況下，分子圖是無向的，因為化學鍵通常沒有方向性。 但在某些情境下，如化學反應網絡中，可以使用有向圖來表示從反應物到產物的轉化流程。 加權圖：雖然在基本分子圖中不常使用，但可以引入加權邊以指示鍵強度、相互作用強度或其他結構行為的先驗知識。 分子圖的表示方法\n鄰接矩陣： 鄰接矩陣提供了一種表格式的圖表示，其中每個單元格表示原子之間是否存在鍵（或鍵的類型）。例如，若原子 i i 和 j j 之間 …","date":1734825600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1734825600,"objectID":"dcd8b9004a9d9a427f0bc9caab34170b","permalink":"http://localhost:56953/post/compbio_gnn/","publishdate":"2024-12-22T00:00:00Z","relpermalink":"/post/compbio_gnn/","section":"post","summary":"","tags":["Computational biology","Graph nueral network"],"title":"計算生物學聊聊：圖神經網路與分子圖形","type":"post"},{"authors":["戴揚紘",""],"categories":["論文技術分享"],"content":"近期發表於《科學》期刊的研究介紹了Evo，一種具備7億參數的基因組基礎模型 (Foundation model)，能夠從單個核苷酸到整個基因組進行序列建模和設計。 Evo使用StripedHyena架構，能夠以接近線性的計算和記憶體擴展來處理長序列，實現單核苷酸級別的解析度。 該模型在OpenGenome資料集上進行訓練，該資料集包含約270萬個原核生物和噬菌體基因組序列，總計約3000億個標記。 Evo在DNA、RNA和蛋白質等多種生物模式下的零樣本 (Zero shot)功能預測任務中表現出色，並能夠生成功能性生物系統，如CRISPR-Cas複合物和轉座子。\n架構：採用了 StripedHyena，這是一種混合注意力-卷積架構，能夠以單核苷酸級別的解析度高效處理長序列數據。 訓練：基於 270 萬個基因組進行訓練，支持最長 131kb 的上下文長度。 應用：在突變效應的零樣本預測，以及操縱子、CRISPR 系統和大型基因組序列的生成方面有著出色表現。 何謂Zero shot? Zero-shot prediction 指的是一種機器學習模型能夠在從未見過或未特別訓練過的任務上進行推斷和預測的能力。這種方法的核心理念是利用模型的泛化能力，讓模型在沒有明確針對目標任務的標訓練數據下，依賴其先前學到的知識完成新任務。\n","date":1734739200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1734739200,"objectID":"b26df7357bd21817cea31bd5c35a40fe","permalink":"http://localhost:56953/tech/tech3/","publishdate":"2024-12-21T00:00:00Z","relpermalink":"/tech/tech3/","section":"tech","summary":"","tags":["Computational biology"],"title":"Sequence modeling and design from molecular to genome scale with Evo","type":"tech"},{"authors":["戴揚紘",""],"categories":["Python迷你課程"],"content":"Quick look 在 Python 中，字串 (string) 是最常用的資料類型之一。掌握字串的基本操作和進階技巧，不僅能讓你的程式碼更簡潔，也能提升程式設計的靈活性。本文將基於範例程式碼進一步詳細講解，並延伸至更多實用的字串操作和格式化方法。\n輸出 print(\u0026#34;Hello, World!\u0026#34;) 這是 Python 中最基本的輸出語句，用於在terminal (終端) 顯示文字。\n字串格式化 Python 3.6 版之後引入f-string的格式化方式，語法簡潔易懂。\nname = \u0026#34;Micha\u0026#34; print(f\u0026#34;Hello, {name}!\u0026#34;) 格式化數字 可以針對一串數字中間加逗號，對一些需要這樣處理的數字很方便。\nz = 1234567 print(f\u0026#34;{z:,}\u0026#34;) # 輸出: 1,234,567 保留小數位數 z = 1234.56789 print(f\u0026#34;{z:.2f}\u0026#34;) # 輸出: 1234.57 跳脫字符 print(\u0026#34;She said, \\\u0026#34;Hello!\\\u0026#34;\u0026#34;) # 使用 \\\\ 處理雙引號 #\u0026gt;\u0026gt;\u0026gt; She said, \u0026#34;Hello!\u0026#34; 活用print() 要輸出的字可以在print()內用+號來結合：\nprint(\u0026#39;Hello\u0026#39;+\u0026#39;Micha\u0026#39;) #\u0026gt;\u0026gt;\u0026gt; HelloMicha 但我們發現到兩個字串連在一起，這是因為+會默認中間沒有空格，所以這樣的情況下應該要：\nprint(\u0026#39;Hello \u0026#39;+\u0026#39;Micha\u0026#39;) 如果不要用+，可以直接使用,，這樣就不會默認中間沒有空格：\nprint(\u0026#39;Hello\u0026#39;,\u0026#39;Micha\u0026#39;) ##輸出Hello Micha 當然，我們可以在print()內修改參數，讓上面的輸出沒有空格：\nprint(\u0026#39;Hello\u0026#39;,\u0026#39;Micha\u0026#39;, sep=\u0026#39;\u0026#39;) ##輸出HelloMicha 這是因為print() default中設定sep=’ ‘，所以平時用逗號分割時中間會有空格。\n換行 如果我們希望Micha出現在下一行該怎麼做？ 第一種最簡單的做法：\nprint(\u0026#39;Hello\u0026#39;) print(\u0026#39;Micha\u0026#39;) 這是因為print() default 會有一個參數end = \u0026#39;\\n\u0026#39;，所以只要每一行都輸入print()，輸出就會分行。但這樣會增加代碼的行數，如果我們想要縮成一行該怎麼做？可以在中間插入\\n。\nprint(\u0026#39;Hello \\nMicha\u0026#39;) #輸出會跟上面一樣 使用者輸入 使用 input() 函數接受使用者輸入：\nname = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) print(f\u0026#34;Hello, {name}!\u0026#34;) 萬一使用者不小心輸入多餘的空格，我們可以用strip()來處理：\nname = name.strip() # 去除前後空白 輸入字母大寫 可以針對輸入的字串做大寫轉換：\nname = \u0026#34;micha\u0026#34; print(name.capitalize()) #輸出Micha 但如果想要輸入的多個字串都大小開頭，需要使用title()：\nname = \u0026#34;micha wu\u0026#34; print(name.title()) #輸出Micha Wu 整合處理 name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;).strip().title() print(f\u0026#34;Hello, {name}!\u0026#34;) 自串分割 分割字串： 使用 split() 方法將字串分割為多個部分：\nfull_name = \u0026#34;Micha Wu\u0026#34; first, last = full_name.split(\u0026#34; \u0026#34;) print(first) # 輸出: Micha print(last) # 輸出: Wu 合併字串 使用 join() 方法將列表中的元素合併為字串：\nwords = [\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;] sentence = \u0026#34; \u0026#34;.join(words) print(sentence) # 輸出: Hello World 替換字串 text = \u0026#34;I love Micha!\u0026#34; print(text.replace(\u0026#34;Micha\u0026#34;, \u0026#34;Red Bean\u0026#34;)) # 輸出: I love Red Bean! 搜尋字串 text = \u0026#34;I love Micha!\u0026#34; print(text.find(\u0026#34;Micha\u0026#34;)) # 輸出: 7 (Micha 的起始位置) 其他搭配 字串的操作還可以搭配isdigit()、isalpha()、isspace()等，讓字串的操作更為靈活。\n課程小結 功能 操作方法 範例 輸出 基本輸出 print() print(\u0026#34;Hello, World!\u0026#34;) Hello, World! 格式化字串 f-string name = \u0026#34;Micha\u0026#34;\nprint(f\u0026#34;Hello, {name}!\u0026#34;) Hello, Micha! 數字加逗號 f-string 加千分位分隔符 z = 1234567\nprint(f\u0026#34;{z:,}\u0026#34;) 1,234,567 保留小數位數 f-string 保留小數點後兩位 z = 1234.56789\nprint(f\u0026#34;{z:.2f}\u0026#34;) 1234.57 跳脫字符 使用 \\ 處理特殊字符 print(\u0026#34;She said, \\\u0026#34;Hello!\\\u0026#34;\u0026#34;) She said, \u0026#34;Hello!\u0026#34; 字串拼接 + 或 , 進行字串拼接 print(\u0026#39;Hello \u0026#39;+\u0026#39;Micha\u0026#39;)\nprint(\u0026#39;Hello\u0026#39;, \u0026#39;Micha\u0026#39;) Hello Micha 字串合併 join() words = [\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;]\nsentence = \u0026#34; \u0026#34;.join(words)\nprint(sentence) Hello World 換行輸出 \\n 或多次 print() print(\u0026#39;Hello \\nMicha\u0026#39;) Hello\nMicha 用戶輸入 input() name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;)\nprint(f\u0026#34;Hello, {name}!\u0026#34;) 根據使用者輸入 去除空白 strip() name = \u0026#34; Micha \u0026#34;\nprint(name.strip()) Micha 首字母大寫 capitalize() name = \u0026#34;micha\u0026#34;\nprint(name.capitalize()) Micha 標題格式化 title() name = \u0026#34;micha wu\u0026#34;\nprint(name.title()) Micha Wu 分割字串 split() full_name = \u0026#34;Micha Wu\u0026#34;\nfirst, last = full_name.split(\u0026#34; \u0026#34;) Micha 和 Wu 替換字串 replace() text = \u0026#34;I love Micha!\u0026#34;\nprint(text.replace(\u0026#34;Micha\u0026#34;, \u0026#34;Red Bean\u0026#34;)) I love Red Bean! 搜尋字串 find() text = \u0026#34;I love Micha!\u0026#34;\nprint(text.find(\u0026#34;Micha\u0026#34;)) 7 檢查字串內容 isdigit(), isalpha(), isspace() s = \u0026#34;12345\u0026#34;\nprint(s.isdigit()) True 整合處理 strip() + title() name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;).strip().title()\nprint(f\u0026#34;Hello, {name}!\u0026#34;) 格式化的用戶輸入結果 ","date":1734739200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1734739200,"objectID":"88315b4bc331e627b896cd1880b27930","permalink":"http://localhost:56953/post/minicoursepython1/","publishdate":"2024-12-21T00:00:00Z","relpermalink":"/post/minicoursepython1/","section":"post","summary":"","tags":["Python","coding"],"title":"迷你課程:Python-1~字串操作與格式化","type":"post"},{"authors":["戴揚紘",""],"categories":["計算生物學"],"content":"Quick look 本篇介紹藥物開發的現況，筆記出自於美國麻省理工學院的計算生物學課程MLCB24。 課程影片請看這裡。\n藥物的定義 從技術角度來說，藥物被定義為由藥典或藥物配方手冊所認可的物質。它必須符合嚴格的標準，包括其成分、製造過程及純度等方面的要求。詳細的定義包括：\n用途：藥物旨在用於診斷、治療、緩解、治癒或預防疾病。這一用途將它與其他物質或化合物區分開來。 法規：藥物在法規上與食品和醫療器材分開進行管理。儘管存在像醫療食品這樣專為特定疾病的飲食需求而設計的特殊分類，但這些並未被歸類為藥物。此外，醫療器材雖然對醫療非常重要，但它們遵循獨立的法規。 藥物主要分為兩大類：\n小分子藥物：這些是化學合成的化合物，傳統上是製藥研究的重點，通常以口服或注射形式服用。 生物製劑：這些是由活細胞或生物體生產的較大且更複雜的分子，包括抗體、疫苗和基因療法。生物製劑通常需要更複雜的製造過程及保存系統。 藥物在人類歷史中的角色 藥物的使用與發展深深植根於人類歷史，幾乎每個文化都探索過藥用物質。從歷史上看，早期的藥物發現通常來自於大自然，尤其是植物，並受到傳統知識的傳承。以下是一些常見起源於古代的藥物：\n罌粟萃取物：歷史上用於止痛，罌粟萃取物促成了鴉片類藥物（例如嗎啡和可待因）的發現，這些藥物至今仍是疼痛管理的重要工具。 柳樹皮：傳統上用於退燒，後來從中分離出水楊酸，成為阿司匹靈的基礎——這是最廣泛使用的抗炎和止痛藥之一。 青蒿（Artemisia，甜艾草）：在中國醫學中被用於治療發燒，後來提供了強效抗瘧藥物青蒿素。 這些例子說明了天然產物如何成為藥物發現的起點，而這一趨勢至今仍在持續。然而，現代的藥物開發方式已經大大進化，呈現出更加複雜的科學、法規和技術框架。\n現代藥物發現的框架 現代藥物發現的框架是一個結構化、目標導向且跨學科的過程，其目的是將最初的科學研究轉化為具有商業價值的藥物。與傳統依賴運氣或簡單試錯的方法不同，現代藥物發現基於對分子途徑、疾病機制和目標治療設計的深入理解。\n從基礎科學到藥物治療 藥物發現的過程始於對疾病相關分子途徑的科學研究。研究人員會找出疾病的靶點——一個對疾病病理至關重要的蛋白質、基因或細胞機制。通過理解這些靶點如何運作，他們可以有針對性地尋找能與靶點相互作用的治療劑，藉此改變或抑制其功能以產生有益效果。這些治療劑可以是小分子、生物製劑（如抗體）甚至是具有生物活性的天然產物。\n藥物發現的跨學科性 這個過程極具跨學科特性，需要以下專家的貢獻：\n生物學家和化學家：理解疾病機制並設計具有預期特性的分子。 工程師與生物資訊學專家：優化配送系統和預測藥物行為的計算模型。 計算生物學家：利用生物資訊工具分析複雜的生物數據，選擇有潛力的靶點並研究分子間的相互作用。 商業與法務專家：確保過程符合法規標準並具有商業價值，處理知識產權（IP）與市場策略。 現代藥物發現的協作特性需要數以千計的人員參與，並可能為單一藥物耗資超過10億美元。這種高成本部分源於像美國食品藥品監督管理局（FDA）等法規機構制定的嚴格標準，這些標準要求提供藥物有效性與安全性的證據。雖然這些標準保護患者安全，但同時大幅增加了開發過程的時間、複雜性及成本。\n商業模式在藥物開發中的角色 製藥公司之所以願意投入藥物開發，是因為專利藥物的高利潤。然而，這種激勵旨在推動創新，但有時可能與治療需求相衝突。理想情況下，治療需求與市場激勵是一致的；然而，特別是在商業模式無法支持低市場吸引力領域的開發時，這種一致性並非總是存在。\n例如，抗生素的開發便是一個獨特的案例。隨著抗生素耐藥性的增加，對新型抗生素的需求也愈發迫切，但開發它們的商業激勵卻非常薄弱。如果一家製藥公司開發了一種新抗生素，可以有效對抗耐藥細菌，最佳的使用策略可能是限制其在醫院或是社區的使用，以保持其效力並減少耐藥性的產生。然而，有限的使用會降低銷售量，使這種產品的利潤遠低於需要定期、長期使用的藥物。結果，儘管抗生素對全球健康至關重要，但過去幾十年裡新抗生素的投資卻很少。\n調整商業與治療需求的新模式 針對像抗生素這樣的案例，商業模式與公共衛生需求之間的不匹配促使研究人員和政策制定者探索替代模式，包括：\n政府資金和補貼：用於分攤開發成本並鼓勵對低市場回報領域的研究。 訂閱模式：醫療系統支付固定金額以獲取抗生素，而不取決於其實際使用頻率，這樣可以讓公司有動機投資抗生素開發。 專利延長與市場專有權（exclusivity）：提供更長的專有權，以增加投資回報的可能性。 現代藥物發現框架因此不僅是一個科學和技術的工程，也是一個法規和經濟的挑戰。\n藥物的類型 在現代醫學中，藥物可以大致分為小分子藥物和生物製劑兩大類，每種類型都有獨特的特性、製造需求和法規途徑。除此之外，還有一些創新的藥物類別，例如活性生物治療劑與細胞療法，這些類別代表了治療開發的新前沿。\n小分子藥物 小分子藥物是低分子量化合物（通常小於900 daltons），一般通過化學合成製備。這些藥物常從天然來源中提取的化合物進行優化，其分子小的特性使它們可以穿透細胞膜，有效針對細胞內的蛋白質目標。\n合成方式：通常為化學合成，初期可能基於天然產物的結構改造。 給藥方式：多為口服，但有時會使用局部塗抹或注射方式。 例子：阿司匹靈（aspirin）、二甲雙胍（metformin）及他汀類藥物（statins）。 生物製劑 優點：口服、製備與分配簡易、製造成本較低。 生物製劑 生物製劑是一類由生物來源衍生的藥物，通常包括較大的分子結構，如蛋白質、抗體和其他細胞產品。與小分子藥物不同，生物製劑通常需要注射或靜脈輸液方式給藥，因為其複雜結構會在消化系統中分解。\n例子：乳癌治療藥物Herceptin和糖尿病用胰島素。\n優點：高度專一性，off target 毒性較小。 活性生物治療劑 活性生物治療劑是使用活微生物（如益生菌）作為治療劑，旨在利用有益菌調節健康。例如，某些健康個體腸道中的特定細菌可能在某些疾病患者中缺乏，恢復這些細菌可能具有治療效果。\n優點：毒性小、效果持久（如果細菌建立了穩定的菌落）。 細胞療法 細胞療法使用活細胞（通常是患者或捐贈者的細胞）來治療疾病，例如CAR-T細胞療法用於癌症治療，幹細胞療法則用於組織再生。\n藥物動力學（Pharmacokinetics, PK）：人體如何處理藥物 藥物動力學是藥物開發中的核心概念，研究藥物進入人體後的作用過程。相對地，藥效學（Pharmacodynamics, PD）則專注於藥物對人體的作用。藥物動力學對於劑量設計、給藥方式、生物利用度和潛在副作用的評估非常重要。PK研究主要涉及四個階段：吸收、分布、代謝和排泄（縮寫：ADME）。\n吸收（Absorption） 吸收是藥物進入血液或作用部位的過程。影響吸收的因素包括：\n給藥途徑：例如口服、靜脈注射或吸入。某些途徑能更快或更直接地實現吸收。 藥物的化學特性：如親水性（溶於水）或疏水性（溶於脂肪）。 環境條件：例如吸收部位的血流量與pH值，這些因素會增強或抑制藥物穿越細胞膜的能力。 藥物的吸收效率決定了其生物利用度（bioavailability），即進入系統循環且以活性形式存在的藥物比例。\n分布 (Distribution) 分布是指藥物從血液移動到身體不同組織的過程。關鍵考量包括：\n血流量：高血流量的器官（如心臟和肝臟）通常更快接收藥物。 蛋白質結合：藥物可能與血液中的血漿蛋白結合，從而限制了可自由發揮療效的藥物量。 跨越選擇性屏障的能力：例如血腦屏障（BBB）。 分布的一個關鍵指標是分布容積（Vd），它反映了藥物在身體中相對於血液中濃度的分散程度。\n血腦屏障是分隔血液與大腦細胞外液的選擇性半透屏障。這一緊密結合的內皮細胞結構只允許特定分子通過，從而保護大腦免受潛在有害物質的侵害。然而，對於治療中樞神經系統疾病的藥物，血腦屏障會帶來挑戰：\n大分子或親水性分子難以穿透血腦屏障。 解決策略：\n設計具有更高血腦屏障穿透性的藥物。 使用奈米粒子傳輸系統幫助藥物穿越屏障。 鼻腔給藥：通過鼻腔直接進入神經通路繞過血腦屏障，但是如果想要藥物在腦中有較高的劑量，這種方式效果較差。 代謝 (Metabolism) 代謝將藥物轉化為更易於排泄的水溶性形式，主要在肝臟中進行，分為兩個階段：\n修飾（Phase I）：包括酶（如細胞色素P450家族）的氧化或還原作用，使藥物變得更具反應性。 結合（Phase II）：增加極性基團（如葡萄糖醛酸化），提升藥物的溶解性，便於排泄。 代謝可能活化藥物、將其轉化為不活躍的代謝產物，或者在某些情況下產生有毒的中間產物。例如，對乙醯氨基酚（acetaminophen）在高劑量下會生成一種有毒中間產物，可能導致肝損傷。 排泄 (Excretion) 排泄是將藥物及其代謝物從體內移除的過程。常見途徑包括：\n腎臟（尿液）：最常見的排泄方式，處理水溶性代謝物。 肝臟（膽汁）：某些代謝物通過膽汁分泌，最終經糞便排泄。 其他途徑：如汗液、呼吸和母乳，但這些途徑的貢獻較小。 排泄的效率影響藥物的半衰期（half-life），這對於確定給藥頻率以維持治療濃度且不引起毒性非常重要 (圖一)。 圖一 Modelling of PK 有兩種方式：\nOne component model：假設人體是一個單一的均勻區室，藥物在進入人體後立即均勻分布整個區室，並隨時間經由代謝或排泄而逐漸被清除。 Two component model：描述藥物在體內分佈（Distribution phase）與排除（Elimination phase）的過程，分成中央區室與周邊區室，比單一區室的模型更為準確。 藥效學（Pharmacodynamics, PD）：藥物對人體的作用 藥效學研究藥物如何與受體、酶或其他細胞靶點作用以產生生物學反應，重點包括藥物作用機制、劑量-反應關係以及治療效果與毒性效應的區分。深入了解藥效學有助於設計療效最大化、副作用最小化的藥物。\n藥物與受體的相互作用 大多數小分子藥物通過與特定受體（通常是細胞信號通路或酶作用相關的蛋白質）結合來發揮作用。主要的交互方式包括：\n活化劑（Agonists）：活化目標受體以產生生物反應。 拮抗劑（Antagonists）：與受體結合但阻止其活化，有效抑制反應。 部分活化劑（Partial Agonists）：與受體結合並活化受體，但反應較全活化劑弱。 親和力與效價\n親和力（Affinity）：描述藥物與受體的結合強度。高親和力的藥物更容易結合，且效果更持久。 效價（Potency）：通常用半最大有效濃度（EC50）衡量，即藥物達到50%最大效果所需的濃度。 劑量-反應關係 劑量-反應曲線顯示藥物劑量與生物效應的關係。關鍵指標包括：\n最大效應（Emax）：藥物能產生的最大效果，無關劑量。 藥效（Efficacy）：藥物能達到的藥效，在合理劑量內。 治療窗（Therapeutic Window）：能夠產生治療效果而不引起毒性的劑量範圍。 藥物毒理學（Toxicology）：評估藥物的安全性與副作用 毒理學是研究藥物潛在不良反應的學科，在藥物被批准使用之前，確保其安全性是非常重要的。這一領域評估藥物在各種系統與情境下中毒的風險，確保藥物在達成治療目標的同時，不會對健康造成不可接受的影響。\n毒理學研究涵蓋藥物安全性的多個面向，包括：\n急性毒性：觀察藥物給藥後的即時反應，幫助識別早期副作用或毒性反應。 DNA損傷：測試藥物是否會導致基因毒性效應，如突變或致癌風險。 生殖健康：評估藥物對生育能力、胎兒發育及後代健康的影響，這對於針對育齡人群的藥物尤為重要。 致癌性：研究長期暴露於藥物是否會增加癌症風險。這類研究通常耗時且成本高，需進行長期觀察。 此外，還會針對特定器官進行毒性研究，例如中樞神經系統、呼吸系統和心血管系統。這些研究通常在動物模型中進行，以確保在人類試驗之前，不會出現嚴重器官損害。\n治療指數（Therapeutic Index, TI）與其重要性 治療指數（TI）是衡量藥物安全性的重要指標，反映藥物的有效劑量與毒性劑量之間的差 …","date":1734220800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1734220800,"objectID":"8b78c474e8e547bd57fe7f117214097f","permalink":"http://localhost:56953/post/compbio_drug/","publishdate":"2024-12-15T00:00:00Z","relpermalink":"/post/compbio_drug/","section":"post","summary":"","tags":["Computational biology","Drug development"],"title":"計算生物學聊聊：藥物開發的現況與挑戰","type":"post"},{"authors":["戴揚紘",""],"categories":["R語言迷你課程"],"content":"Quick look 本次課程將介紹 R 語言中與字串相關的各種操作方法，包括字串的建立、分割、拼接、取子字串、查找與替換，以及字串的轉換與處理。\nR 中的字串屬於 character 類型，是一種重要的資料結構，特別是在文字處理、資料清理與分析中經常使用。\n字串的建立 在 R 中，字串用雙引號 \u0026#34;\u0026#34; 或單引號 \u0026#39;\u0026#39; 建立：\n# 建立字串 str1 \u0026lt;- \u0026#34;Hello, World!\u0026#34; str2 \u0026lt;- \u0026#39;R is powerful!\u0026#39; # 查看字串類型 class(str1) # 輸出: \u0026#34;character\u0026#34; 若需包含雙引號或單引號，可以用反斜槓 \\ 進行跳脫：\nstr3 \u0026lt;- \u0026#34;He said, \\\u0026#34;R is amazing!\\\u0026#34;\u0026#34; print(str3) # 輸出: He said, \u0026#34;R is amazing!\u0026#34; 字串的基本操作 1. 拼接字串 使用 paste() 和 paste0() 函數來拼接字串：\npaste(): 會自動加入分隔符（預設為空格） paste0(): 不加入任何分隔符 # 拼接字串 first_name \u0026lt;- \u0026#34;James\u0026#34; last_name \u0026lt;- \u0026#34;Dai\u0026#34; full_name \u0026lt;- paste(first_name, last_name) print(full_name) # 輸出: \u0026#34;James Dai\u0026#34; # 無分隔符拼接 full_name_no_space \u0026lt;- paste0(first_name, last_name) print(full_name_no_space) # 輸出: \u0026#34;JamesDai\u0026#34; 2. 字串長度 使用 nchar() 函數計算字串的長度：\nnchar(full_name) # 輸出: 9 3. 取子字串 使用 substr() 和 substring() 提取字串的特定部分：\n# 提取子字串 substr(full_name, 1, 5) # 從第1個字元到第5個字元 # 輸出: \u0026#34;James\u0026#34; # substring 的用法 substring(full_name, 7) # 從第7個字元開始到結尾 # 輸出: \u0026#34;Dai\u0026#34; 字串的分割 使用 strsplit() 函數根據指定分隔符分割字串：\n# 分割字串 sentence \u0026lt;- \u0026#34;apple,banana,cherry\u0026#34; words \u0026lt;- strsplit(sentence, \u0026#34;,\u0026#34;) print(words[[1]]) # 輸出: \u0026#34;apple\u0026#34; \u0026#34;banana\u0026#34; \u0026#34;cherry\u0026#34; 注意：strsplit() 返回的是一個列表，因此要用 [[1]] 提取結果。\n使用 tidyverse 的 separate() 分割資料框中的字串 如果有多筆名字資料，tidyverse 提供了一個方便的函數 separate() 來分割字串，並將其拆分成多個欄位：\nlibrary(tidyverse) # 建立資料框 name_data \u0026lt;- tibble(full_name = c(\u0026#34;James Dai\u0026#34;, \u0026#34;Anna Smith\u0026#34;, \u0026#34;John Doe\u0026#34;)) # 使用 separate 分割 full_name 欄位 name_data \u0026lt;- name_data %\u0026gt;% separate(full_name, into = c(\u0026#34;first_name\u0026#34;, \u0026#34;last_name\u0026#34;), sep = \u0026#34; \u0026#34;) # 查看結果 print(name_data) 輸出結果：\n# A tibble: 3 x 2 first_name last_name \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; 1 James Dai 2 Anna Smith 3 John Doe 字串的查找與替換 1. 查找特定字串 使用 grep() 或 grepl() 來查找字串：\ngrep(): 返回匹配的索引位置 grepl(): 返回布林值向量 # 查找字串 fruits \u0026lt;- c(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) index \u0026lt;- grep(\u0026#34;apple\u0026#34;, fruits) print(index) # 輸出: 1 contains_apple \u0026lt;- grepl(\u0026#34;apple\u0026#34;, fruits) print(contains_apple) # 輸出: TRUE FALSE FALSE 2. 替換字串 使用 gsub() 和 sub() 進行字串替換：\ngsub(): 替換所有匹配的字串 sub(): 只替換第一個匹配的字串 # 替換字串 text \u0026lt;- \u0026#34;I love R. R is amazing!\u0026#34; new_text \u0026lt;- gsub(\u0026#34;R\u0026#34;, \u0026#34;Python\u0026#34;, text) print(new_text) # 輸出: \u0026#34;I love Python. Python is amazing!\u0026#34; 字串的類型轉換 (Coercion) 在 R 中，當不同類型的資料組合時，R 會自動進行 coercion（類型強制轉換）。字串會被視為最高類型，並將其他資料類型轉換成 character。\n# 自動轉換 mixed_vec \u0026lt;- c(\u0026#34;R\u0026#34;, 1, TRUE) print(mixed_vec) # 輸出: \u0026#34;R\u0026#34; \u0026#34;1\u0026#34; \u0026#34;TRUE\u0026#34; # 手動轉換 num_to_char \u0026lt;- as.character(123) print(num_to_char) # 輸出: \u0026#34;123\u0026#34; char_to_num \u0026lt;- as.numeric(\u0026#34;123\u0026#34;) print(char_to_num) # 輸出: 123 字串與 S4 物件的轉換 對於複雜結構的物件，可以使用 as() 進行轉換：\n# 使用 as 進行轉換 s4_object \u0026lt;- as(c(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;), \u0026#34;character\u0026#34;) print(s4_object) # 輸出: \u0026#34;x\u0026#34; \u0026#34;y\u0026#34; \u0026#34;z\u0026#34; 課程小結 操作類型 函數名稱 範例 字串拼接 paste(), paste0() paste(\u0026#34;James\u0026#34;, \u0026#34;Dai\u0026#34;) 取字串長度 nchar() nchar(\u0026#34;James\u0026#34;) 提取子字串 substr(), substring() substr(\u0026#34;James\u0026#34;, 1, 3) 分割字串 strsplit(), separate() strsplit(\u0026#34;a,b,c\u0026#34;, \u0026#34;,\u0026#34;) 查找字串 grep(), grepl() grep(\u0026#34;apple\u0026#34;, fruits) 替換字串 gsub(), sub() gsub(\u0026#34;R\u0026#34;, \u0026#34;Python\u0026#34;, text) 類型轉換 as.character(), as.numeric() as.character(123) 掌握這些字串操作技巧，將能有效地處理各種文字資料，並在資料分析、清洗與視覺化過程中發揮重要作用！\n","date":1734220800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1734220800,"objectID":"091d152bd1ffbcd963dae5f44ea5cf42","permalink":"http://localhost:56953/post/minicourser5/","publishdate":"2024-12-15T00:00:00Z","relpermalink":"/post/minicourser5/","section":"post","summary":"","tags":["R","coding"],"title":"迷你課程:R語言-5~R的字串操作","type":"post"},{"authors":["戴揚紘",""],"categories":["R語言迷你課程"],"content":"Quick look 在 R 語言中，函數能夠幫助我們培養重複使用和結構化程式的能力。本篇文章將介紹：\nR 函數如何定義。 函數使用的優化方式。 常用的有用函數和工具。 如何定義函數 基本定義如下：\nmy_function \u0026lt;- function(arg1, arg2) { result \u0026lt;- arg1 + arg2 return(result) } my_function(5, 10) # 返回 15 function() 定義函數。\n參數 (例如 arg1 和 arg2) 可指定多個。\nreturn() 指定返回值，若未指定則默認返回最後一行的計算結果。\n我們可以根據上面的格式來寫一個寫當的平方函數：\nsquare \u0026lt;- function(x){ y \u0026lt;- x^2 return(y) } 函數在R也是一種物件（object），所以這邊新建立的square也是一個函數物件，可以用來進行輸入參數的平方運算，然後返回運算後的值，但其實這個寫法可以再精簡，因為如果你還記得，未指定則默認返回最後一行的計算結果，所以可以精簡成：\nsquare \u0026lt;- function(x){ x^2 } 如此一來square(3)就會自動印出9，同樣的結果，但是少了assignment與return兩個操作。\n默認值 R 允許在定義函數時設定參數的默認值，這樣就不用在運算時每次都要把全部參數寫出來：\nmy_function \u0026lt;- function(arg1, arg2 = 10) { result \u0026lt;- arg1 + arg2 return(result) } my_function(5) # 返回 15，因為 arg2 默認為 10 不定數量參數 R 允許定義不定數量的參數：\nmy_function \u0026lt;- function(...) { args \u0026lt;- list(...) sum(args) } my_function(1, 2, 3, 4) # 返回 10 再看另一個例子：\nfun \u0026lt;- function(..., fun=mean, p =0.5){ x \u0026lt;- c(...) x-fun(x) } fun(10,30,40,50) 因為可以讓使用者輸入任意數量的數字，然後再轉換成向量，增加函式的彈性。\n#\u0026gt; [1] -22.5 -2.5 7.5 17.5 避免重複代碼 將常用函數放到函數裡，以減少重複代碼：\nnormalize \u0026lt;- function(x) { (x - min(x)) / (max(x) - min(x)) } normalize(c(1, 2, 3, 4, 5)) 加入錯誤處理 使用 stop() 來對函數輸入進行檢查：\nsafe_divide \u0026lt;- function(a, b) { if (b == 0) stop(\u0026#34;分母不能為 0\u0026#34;) a / b } safe_divide(10, 2) # 返回 5 safe_divide(10, 0) # 結束執行並出現錯誤訊息 搭配do.call() 使用 do.call() 來加強函數的呼叫：\nsum_values \u0026lt;- function(...) { sum(...) } do.call(sum_values, list(1, 2, 3, 4)) # 返回 10 需要注意的是，do.call() 的第一個參數為函數名稱，第二個參數為需要被這個函數呼叫的元素list，如果list中只有一個atomic vector，該函數將把這個向量作為單一參數處理（例如，作為一個整體傳遞）。如果list中有數個vectors，do.call() 會將 list 的元素解構為函數的獨立參數，依序傳入。如把vector1中的第一個元素和vector2中的第一個元素當作參數，以此類推。\n# 單一 atomic vector 作為 list 中唯一元素 do.call(sum, list(c(1, 2, 3, 4))) # 等同於 sum(c(1, 2, 3, 4))，結果是 10 # 多個向量作為 list 中的元素 do.call(paste, list(c(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;), c(\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;), sep = \u0026#34;-\u0026#34;)) # 等同於 paste(\u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;, sep = \u0026#34;-\u0026#34;) 和 paste(\u0026#34;B\u0026#34;, \u0026#34;D\u0026#34;, sep = \u0026#34;-\u0026#34;) # 結果是 \u0026#34;A-C\u0026#34; 和 \u0026#34;B-D\u0026#34; 如果還記得data frame 是list的集合，所以我們可以將data frame 當成參數。如果要新增一欄list做處理，需要用c():\ndf \u0026lt;- data.frame(first = c(1,2,3), second = c(2,4,6)) do.call(paste, c(df,\u0026#39;+\u0026#39;)) 會得到：\n#\u0026gt; [1] \u0026#34;1 2 +\u0026#34; \u0026#34;2 4 +\u0026#34; \u0026#34;3 6 +\u0026#34; 使用重要套件 和 purrr 套件配合：\nlibrary(purrr) square \u0026lt;- function(x) x^2 map(c(1, 2, 3, 4), square) # 返回 1, 4, 9, 16 map為purrr套件中的好用函式，之後會專門討論。\n輸入驗證 library(assertthat) assert_that(is.numeric(10)) # 通過 接合與對齊 使用mapply() 與 apply() 。\nmapply(function(x, y) x + y, 1:3, 4:6) # 返回 5, 7, 9 mapply() 是一個向量化函數，適用於對多個向量或列表同時應用一個函數。它的功能相當於對多個對應元素進行逐一計算。\n其實不難發現，上面的運算等同於：\ndo.call(function(x, y) x + y, list(c(1,2,3), c(4,5,6))) mat \u0026lt;- matrix(1:6, nrow = 2) apply(mat, 1, sum) # 對每一列求和 # Output: c(9, 12) apply(mat, 2, sum) # 對每一欄求和 # Output: c(3, 7, 11) 功能 mapply() apply() 適用場景 對多個向量或列表逐一操作 對矩陣或數據框的行或列進行批量操作 輸入數據類型 向量、列表 矩陣、數據框 返回值 簡化後的向量或列表 矩陣、數據框，或者簡化後的向量 常見應用 處理多組向量對應元素的計算 操作數據的每一行或每一列 課程小結 主題 特性 範例 函數定義 使用 function() 定義帶有參數和返回值的函數 my_function \u0026lt;- function(x, y) x + y 默認值 可為函數參數設定默認值 my_function \u0026lt;- function(x, y = 10) 不定數量參數 使用 ... 接收任意數量的輸入參數 my_function \u0026lt;- function(...) sum(...) 重複代碼優化 通過函數封裝常用邏輯來減少重複代碼 normalize \u0026lt;- function(x) (x - min(x)) / (max(x) - min(x)) 錯誤處理 使用 stop() 進行輸入檢查與報錯 safe_divide \u0026lt;- function(a, b) if (b == 0) stop(\u0026#34;分母不能為 0\u0026#34;) do.call() 將列表解構為函數參數 do.call(sum, list(1, 2, 3, 4)) 搭配 purrr 套件 使用 map() 對向量逐一應用函數 map(c(1, 2, 3), ~ .x^2) 向量化運算 使用 mapply() 處理多組向量 mapply(function(x, y) x + y, 1:3, 4:6) 行列操作 使用 apply() 處理矩陣行或列的計算 apply(matrix(1:6, nrow = 2), 1, sum) ","date":1734134400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1734134400,"objectID":"0ce4633849c290ae1c96f00561424da9","permalink":"http://localhost:56953/post/minicourse_r4/","publishdate":"2024-12-14T00:00:00Z","relpermalink":"/post/minicourse_r4/","section":"post","summary":"","tags":["R","coding"],"title":"迷你課程:R語言-4~Function的定義與運用","type":"post"},{"authors":["戴揚紘",""],"categories":["數位病理"],"content":"Abstract The rapidly emerging field of computational pathology has the potential to enable objective diagnosis, therapeutic response prediction and identification of new morphological features of clinical relevance. However, deep learning-based computational pathology approaches either require manual annotation of gigapixel whole slide images (WSIs) in fully-supervised settings or thousands of WSIs with slide-level labels in a weakly-supervised setting. Moreover, whole slide level computational pathology methods also suffer from domain adaptation and interpretability issues. These challenges have prevented the broad adaptation of computational pathology for clinical and research purposes. Here we present CLAM - Clustering-constrained attention multiple instance learning, an easy-to-use, high-throughput, and interpretable WSI-level processing and learning method that only requires slide-level labels while being data efficient, adaptable and capable of handling multi-class subtyping problems. CLAM is a deep-learning-based weakly-supervised method that uses attention-based learning to automatically identify sub-regions of high diagnostic value in order to accurately classify the whole slide, while also utilizing instance-level clustering over the representative regions identified to constrain and refine the feature space. In three separate analyses, we demonstrate the data efficiency and adaptability of CLAM and its superior performance over standard weakly-supervised classification. We demonstrate that CLAM models are interpretable and can be used to identify well-known and new morphological features. We further show that models trained using CLAM are adaptable to independent test cohorts, cell phone microscopy images, and biopsies. CLAM is a general-purpose and adaptable method that can be used for a variety of different computational pathology tasks in both clinical and research settings.\n","date":1733961600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1733961600,"objectID":"a876e041669c092b52e86cabfbe5f5fb","permalink":"http://localhost:56953/tech/tech2/","publishdate":"2024-12-12T00:00:00Z","relpermalink":"/tech/tech2/","section":"tech","summary":"","tags":["Digital pathology"],"title":"Data Efficient and Weakly Supervised Computational Pathology on Whole Slide Images","type":"tech"},{"authors":["戴揚紘",""],"categories":["計算生物學"],"content":"Quick look Hidden Markov Chain(HMM)是計算生物學中一個重要的數學模型，廣泛應用於DNA序列分析和蛋白質結構預測等領域。HMM的核心概念是用隱藏的狀態來建立模型，並解釋觀察到的數據，通過轉移機率和觀察機率來描述系統的動態行為。\nMarkov chain Markov chain是一種數學模型，用於描述一個系統在離散時間內的狀態轉移過程。它的核心特點是 \u0026#34;無記憶性\u0026#34;，即下一個狀態僅取決於當前狀態，而與過去的狀態無關。\n基本定義 Markov chain 的所有可能狀態的集合，通常表示為：\n$$ S={s1​,s2​,…,sn​} $$ 轉移概率（Transition Probability） 從當前狀態Si 到下一個狀態Sj，記為Pij:\n$$ Pij=P(Xt+1​=Sj​∣Xt​=Si​) $$ 其中，Xt 表示時間t 時系統的狀態\n轉移矩陣（Transition Matrix） $$ P = \\begin{bmatrix} P_{11} \u0026amp; P_{12} \u0026amp; \\ldots \u0026amp; P_{1n} \\\\ P_{21} \u0026amp; P_{22} \u0026amp; \\ldots \u0026amp; P_{2n} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ P_{n1} \u0026amp; P_{n2} \u0026amp; \\ldots \u0026amp; P_{nn} \\end{bmatrix} $$ 每一列的概率總和為 1：\n$$ \\sum_{j}Pij​=1 $$ 初始分佈（Initial Distribution） 系統初始時處於每個狀態的概率，記為向量 π:\n$$ π=[π_1​,π_2​,…,π_n​],\\sum_{i=1}π_i​=1 $$ Markov chain的性質 無記憶性（Markov Property） 下一狀態的分佈僅取決於當前狀態：\n$$ P(Xt+1​=Sj​∣Xt​=Si​,Xt−1​,…,X1​)=P(Xt+1​=Sj​∣Xt​=Si​) $$ 穩態分佈（Stationary Distribution） 當Markov chain運行足夠長時間後，系統的狀態分佈趨於穩定，滿足：\n$$ π = πP $$ Markov chain 實例 假設我們有一個系統，代表每天的天氣狀態，狀態空間為：\n$$ S = [晴天, 雨天] $$ 轉移概率如下：\n晴天後下一天仍是晴天的概率為 0.8; 變為雨天的概率為 0.2。 雨天後下一天變為晴天的概率為 0.6，仍是雨天的概率為 0.4。 轉移矩陣可以表示為：\n$$ P = \\begin{bmatrix} 0.8 \u0026amp; 0.2 \\\\ 0.6 \u0026amp; 0.4 \\end{bmatrix} $$ 初始分佈：\n假設第一天是晴天：\n$$ π=[1,0] $$ 運行Markov chain可以計算未來任一天的天氣分佈。 HMM HMM常用於分析序列數據或時序數據，尤其是當觀察數據（顯性數據）與內部狀態（隱藏狀態）之間存在間接關係時。HMM 是一種生成式模型 (generative model)，通過隱藏狀態的轉移和觀察狀態的生成來描述數據行為。\n類似於Markov chain，HMM除了有觀察狀態之外，還包含了隱藏狀態 (hidden state)，隱藏狀態是一組未直接觀察到的狀態，用來描述系統的內部狀態。如投擲硬幣時，我們只會觀察到正面和反面，但是硬幣是真硬幣還是假硬幣是被隱藏起來的，而隱藏狀態之間的轉移由轉移機率矩陣來描述。而隱藏狀態生成觀察狀態的機率用觀察機率矩陣 (emission probability matrix) 來描述：\n$$ B={b_jk​},b_jk​=P(ok​∣Sj​) $$ HMM 性質 隱藏狀態與觀察數據的關係 隱藏狀態 S 影響觀察數據 O，但隱藏狀態本身無法直接觀測。 每一個觀察 Ot 僅與當前隱藏狀態 St 相關。 隱藏狀態之間的轉移滿足Markov chain property，未來的狀態僅依賴當前狀態，與過去狀態無關。 範例 接下來我來看一個簡單的例子： 圖一 這張圖是一個兩狀態HMM，其中隱藏狀態代表公平硬幣（Fair Coin, F) 與偏斜硬幣（Biased Coin, B)，並包含以下數學定義：\n初始狀態分佈: $$ πF​=0.4,πB​=0.6 $$ 這表示系統初始時處於公平硬幣狀態的機率為 0.4，而偏斜硬幣狀態的機率為 0.6。 轉移機率矩陣 (隱藏狀態的轉移機率): $$ A = \\begin{bmatrix} P(F \\to F) \u0026amp; P(F \\to B) \\\\ P(B \\to F) \u0026amp; P(B \\to B) \\end{bmatrix} = \\begin{bmatrix} 0.9 \u0026amp; 0.1 \\\\ 0.3 \u0026amp; 0.7 \\end{bmatrix} $$ 觀察機率矩陣: 每個隱藏狀態對應不同的觀察機率分佈。\n$$ B = \\begin{bmatrix} P(H \\mid F) \u0026amp; P(T \\mid F) \\\\ P(H \\mid B) \u0026amp; P(T \\mid B) \\end{bmatrix} = \\begin{bmatrix} 0.5 \u0026amp; 0.5 \\\\ 0.8 \u0026amp; 0.2 \\end{bmatrix} $$ 上面的數學描述基本上告訴我們:\n當處於某一隱藏狀態 St 時，根據對應的觀察機率矩陣 B 生成觀察 Ot。例如：\n若 St = F，則生成 H 或 T 的機率皆為0.5。\n若 St = B，則生成 H 的機率為0.8，生成 T 的機率為0.2。\n機率計算 對於給定的觀察序列O = {H, T, H}，我們可以計算總機率：\n$$ P(O∣λ) $$ 然而，上面的總機率必須考慮所有隱藏狀態的序列，即便是 H，有可能 fair coin或是biased coin擲出，而這兩種狀態都必須考慮進來，然後加總。所以一旦序列很長，計算的複雜度會變得很大，導致在計算上無法順利執行，為了解決個問題，接下來會介紹一些常見的HMM演算法來解決這個問題。\nForward procedure 前向算法（Forward Algorithm） 是 HMM 中用於計算觀察序列的總機率 P(O∣λ) 的一種高效動態規劃方法。這個機率表示給定模型參數 λ = (A,B,π) 時，生成觀察序列 O= {o1,o2,…,oT} 的機率。 圖二 如圖二所示，我今天要來計算硬幣投擲序列的總機率，對於HMM來說，當下的隱藏態具有Markov chain property，亦即只依賴前一個隱藏態的分佈與轉移。\n當t=1時，我們看到觀測值為 T，而T的出現機率由初始的隱藏狀態F和B來決定，而F與B分別有一個emission probability，表示由隱藏態映射到觀察值的機率，所以如果一開始投擲硬幣時使用到fair coin的機率為0.6，而使用此硬幣，也就是此狀態投出 T 的機率為0.5，那麼出現 T 的機率為 α1(F) = 0.6 * 0.5 = 0.3。\n但是這還不夠，因為我們必須要考慮所有可能出現的狀態，因此還要考慮biased coin投擲時的情況，如果在biased coin 投擲下出現 T 機率為0.4 * 0.2 = 0.08， 那麼在 t=1 時出現 T 的機率就等於 α1(B) = 0.3 + 0.08 = 0.38。\n我們可以把兩個隱藏狀態映射出來的機率結果當成一個節點 （圖二中紅色的點），而這個節點儲存了隱藏狀態運算的結果，而我們可以把個運算結果傳到下一個觀察時間點，也就是下一次的投擲。\n而這邊有一個很重要的概念就是，下一個觀察值取決於當下的隱藏狀態，而當下的隱藏狀態取決於前一個隱藏態，而非觀察值的結果，因為觀察值是已知，不像隱藏狀態有機率分佈，在了解了這個區別之後，接下來我們要進行下一次的硬幣投擲。 第二次投擲的結果為H，所以累積到第二次投擲，O = {T, H} 的機率為以下所有情況的加總：\n前一個狀態為 F，這次狀態為 F: α1(F) * αFF * bFH 前一個狀態為 B，這次狀態為 F: α1(B) * αBF * bFH 前一個狀態為 F，這次狀態為 B: α1(F) * αFB * bBH 前一個狀態為 B，這次狀態為 B: α1(B) * αBB * bBH 注意α1(F)及α1(B)已經記憶了前一個狀態的結果，所以再往後的運算，更前面的數據結果都可以拋棄，節省記憶體。\n上面的過程可以用以下的數學式來描述：\n初始化： 對於時間 t=1： $$ α_1​(i) =π_i​ \\cdot b_i​(O_1​),1≤i≤N $$ 其中，πi 是初始狀態分佈，bi(O1) 是狀態 si 下產生觀察 O1 的機率。\n遞推（時間 t\u0026gt;1）: 對於每個時間步t = 2,3,4,5…T，計算每個隱藏狀態的 αt​(i)： $$ \\alpha_t(i) = \\left( \\sum_{j=1}^N \\alpha_{t-1}(j) \\cdot a_{ji} \\right) \\cdot b_i(o_t), \\quad 1 \\leq i \\leq N $$ 其中， αt-1(j): 表示前一個時刻在狀態 sj 的機率。 αji: 表示從狀態 sj 轉移到 si 的機率。 bi(Ot): 表示在狀態 si 下生成觀察 Ot 的機率。 用上面的例子來說明，\nαt-1(j) 為 α1(F): 表示前一個狀態為fair coin下的機率結果=0.3。 aji 為 αFF 及 αBF。 bi(Ot) 為 bFH 及 bBH。 結論 HMM 是在 Markov chain 上的擴展，允許狀態是隱藏的（hidden），而我們只能觀察到通過這些狀態生成的觀察值。它由三個主要部分構成：\n隱藏狀態（Hidden States）：如公平硬幣（Fair Coin）或偏斜硬幣（Biased Coin）。 轉移機率（Transition Probabilities）：描述隱藏狀態之間的轉移。 觀察機率（Emission Probabilities）：描述隱藏狀態生成觀察值的可能性。 之後的文章我會探討針對其他演算法及HMM在生物資訊學中的運用。\n","date":1733702400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1733702400,"objectID":"b5a0fe38c49d04c87745213a2ae1f429","permalink":"http://localhost:56953/post/markov/","publishdate":"2024-12-09T00:00:00Z","relpermalink":"/post/markov/","section":"post","summary":"","tags":["Computational biology","data science"],"title":"計算生物學聊聊：Hidden Markov Chain (上)","type":"post"},{"authors":["戴揚紘",""],"categories":["R語言迷你課程"],"content":"Quick look 今天介紹R中如何對 List、Matrix和Array（陣列）進行子集提取（Subsetting）的操作，包含：\n列表的多種提取方式。 矩陣基本子集提取方法。 陣列的多維子集提取技巧。 List的子集提取 先建立一個list\nmy_list \u0026lt;- list( Name = \u0026#34;Yang-Hong\u0026#34;, Age = 35, Scores = c(85.5, 90.2, 78.9), Matrix = matrix(1:9, nrow = 3) ) #\u0026gt; $Name [1] \u0026#34;Yang-Hong\u0026#34; $Age [1] 35 $Scores [1] 85.5 90.2 78.9 $Matrix [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 提取list的元素: # 使用名稱提取 my_list$Name # \u0026#34;Yang-Hong\u0026#34; # 使用雙中括號提取 my_list[[\u0026#34;Age\u0026#34;]] # 35 # 使用數字索引 my_list[[3]] # [85.5 90.2 78.9] 注意上面數字索引的部分需要用[[]]才能完整將元素取出，如果只用[]也可以取出來物件，但是會帶有list的結構。 同理名稱索引也會有一樣的情況。\n提取子列表 但若是要提取一個子列表，就可以用數字加上[]:\n# 提取一個子列表，提取第一個與第二個元素，返回結構仍是一個list sub_list \u0026lt;- my_list[1:2] 鑲嵌提取 如果列表中的元素是更複雜的數據結構，可以進行鑲嵌提取：\n# 提取 Matrix 中的第一列 my_list$Matrix[1, ] # [1 4 7] 另外要注意的是，$支援partial matching，但[[]]不行，因此用[[]]會比較不會出錯。\nMatrix的子集提取 矩陣是一個2維數據結構，僅允許存儲相同類型的數據。可以通過行和列進行子集提取。 先建立一個matrix:\n# 建立一個 3x3 的矩陣 mat \u0026lt;- matrix( data = 1:9, nrow = 3, #根據data長度來調整行與列的數量 ncol = 3, byrow = TRUE #決定依循row方向排列與否。 ) #\u0026gt; [,1] [,2] [,3] [1,] 1 2 3 [2,] 4 5 6 [3,] 7 8 9 提取單個元素 # 提取第一行第一列的元素 mat[1, 1] # [1] 提取整行或整列 # 提取第二列 mat[2, ] # [4 5 6] # 提取第三行 mat[, 3] # [3 6 9] 提取子矩陣 # 提取第一到第二行，第二到第三列的子矩陣 sub_mat \u0026lt;- mat[1:2, 2:3] 得到：\n#\u0026gt; [2 3] [5 6] 保持matrix結構 一般直接取出matrix的整列或整行會得到atomic vector，但若要維持matrix的結構，可以加上參數drop=FALSE:\nmat[, 3, drop=FALSE] 得到：\n#\u0026gt; [,1] [1,] 3 [2,] 6 [3,] 9 邏輯條件提取 可以使用邏輯條件篩選矩陣中的特定元素：\n# 找出矩陣中大於5的元素 mat[mat \u0026gt; 5] # [7 8 6 9] # 設定條件篩選 selected \u0026lt;- mat[mat %% 2 == 0] # 提取偶數 搭配which() 使用which()可以得到符合邏輯條件的元素位置在哪。\nwhich(mat\u0026gt;5) #\u0026gt; [1] 3 6 8 9 #表示在這些位置元素的值\u0026gt;5 上面的位置是順著column來數，所以第三個位置落在第一行第三列，數值為7且大於5，第8個位置落在第三行第二列，數值為6且大於5。\n我們也可以再用這些返回的位置將數值取出來：\nmat[which(mat\u0026gt;5)] #\u0026gt; [1] 7 8 6 9 然而如果希望取出來的位置或index可以給我們行列的配對，在使用which()的時候可以加上arr.ind=TRUE\nwhich(mat\u0026gt;5, arr.ind=TRUE) 會得到確切的行列位置：\n#\u0026gt; row col [1,] 3 1 [2,] 3 2 [3,] 2 3 [4,] 3 3 而這個返回的數據為matrix的結構，而matrix可以當成索引的條件來找出矩陣裡面相對應的元素。\n同樣的道理，如果今天有兩個索引向量一個代表row，一個代表column，用cbind()結合起來的結構也是matrix，也可以丟回去來索引matrix中某row某column的數值。這個在分析基因序列建立矩陣時可能會用到，當成one-hot encoding的方式之一。\nArray的子集提取 陣列是R中的多維數據結構，可以具有多於兩個維度。子集提取時可以按多維索引操作。\n建立array\n# 建立一個3x3x2的三維陣列 arr \u0026lt;- array( data = 1:18, dim = c(3, 3, 2) #代表有兩層，每一層維度=3x3 ) #\u0026gt; 第一層： [,1] [,2] [,3] [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 第二層： [,1] [,2] [,3] [1,] 10 13 16 [2,] 11 14 17 [3,] 12 15 18 提取單個元素 # 提取第一層第一行第二列的元素 arr[1, 2, 1] # [4] 提取整列或整行 # 提取第二層的第三行 arr[, 3, 2] # [16 17 18] # 提取第一層的第二列 arr[2, , 1] # [2 5 8] 提取特定切片 # 提取第一層的所有數據 slice \u0026lt;- arr[, , 1] 邏輯條件提取 array也可以進行邏輯條件選取。\n# 找出所有大於10的元素 arr[arr \u0026gt; 10] # [11 12 13 14 15 16 17 18] # 選擇特定條件的子陣列 selected \u0026lt;- arr[arr %% 3 == 0] 課程小結 資料結構 特性 提取範例 List 可儲存不同型態數據，靈活提取多層結構 my_list[[\u0026#34;Name\u0026#34;]] Matrix 二維結構，行列提取 mat[1, 2] Array 多維結構，支援多層提取 arr[1, 2, 3] ","date":1733616000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1733616000,"objectID":"aa79800449c481848f355310ac438d2f","permalink":"http://localhost:56953/post/minicourse_r3/","publishdate":"2024-12-08T00:00:00Z","relpermalink":"/post/minicourse_r3/","section":"post","summary":"","tags":["R","coding"],"title":"迷你課程:R語言-3~list, matrix與array的子集提取","type":"post"},{"authors":["戴揚紘",""],"categories":["R語言迷你課程"],"content":"Quick look 今天介紹R的兩種重要資料結構：\nData Frame: 傳統的資料表格式，類似於spreadsheet。 Tibble: Data Frame 的現代化版本，具有更直觀的特性與優化。 Data Frame Data Frame 是 R 中常用的資料結構之一，主要用於存儲行列形式的數據。每個column可以包含不同的數據類型(數字、字串、布林值等)，其實就是將list數據框化，但每row內的數據類型必須一致。\n建立 Data Frame 可以使用 data.frame() 函數來建立 Data Frame：\n# 建立一個 Data Frame df \u0026lt;- data.frame( Name = c(\u0026#34;John\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;), Age = c(25, 30, 28), Score = c(85.5, 92.0, 78.5) ) # 查看 Data Frame print(df) #\u0026gt; Name Age Score 1 John 25 85.5 2 Alice 30 92.0 3 Bob 28 78.5 Data frame的操作 df$Name # 使用column name df[, \u0026#34;Age\u0026#34;] # 使用column name df[[\u0026#34;Score\u0026#34;]] # 使用雙中括號 # 獲取row df[1, ] # 第一row # 獲取特定元素，與matrix類似 df[2, 3] # 第2 row第3 column Data Frame 的特性 允許帶有名稱的列和行: 可以使用 names()設置column名，也可以用rownames()設置row名。\nnames(df) \u0026lt;- c(\u0026#34;姓名\u0026#34;, \u0026#34;年齡\u0026#34;, \u0026#34;成績\u0026#34;) 若有需要，也可以將data frame轉換為矩陣：\nas.matrix(df) 常用函數 # 查看結構與摘要 str(df) # 查看結構 summary(df) # 查看摘要統計 Tibble Tibble是tidyverse套件中的Data Frame，提供更友好的功能，特別適合處理大型或複雜數據。\n建立 Tibble 可以使用tibble()函數來建立Tibble：\n# 載入 tidyverse library(tibble) # 建立一個 Tibble tb \u0026lt;- tibble( Name = c(\u0026#34;John\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;), Age = c(25, 30, 28), Score = c(85.5, 92.0, 78.5) ) # 查看 Tibble print(tb) #\u0026gt; # A tibble: 3 × 3 Name Age Score \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; 1 John 25 85.5 2 Alice 30 92.0 3 Bob 28 78.5 Tibble僅顯示前幾行和列的數據，幫助我們快速預覽，避免大數據集導致的視覺上的overload。另外tibble輸出的數據框會帶入每一column的資料型態，幫助我們迅速了解數據框。\nTibble 的優勢 不自動轉換資料類型。 輸出格式簡潔，特別適合大數據集。 使用 $ 提取列，與 Data Frame 一樣簡單。 Tibble與Data Frame的比較 # 將 Data Frame 轉換為 Tibble tb_from_df \u0026lt;- as_tibble(df) # 查看差異 class(df) # \u0026#34;data.frame\u0026#34; class(tb_from_df) # \u0026#34;tbl_df\u0026#34; \u0026#34;tbl\u0026#34; \u0026#34;data.frame\u0026#34; Data Frame 與 Tibble 的操作對比 功能 Data Frame Tibble 建立資料結構 data.frame() tibble() 取值方式 df[1, \u0026#34;Name\u0026#34;] 或 df$Name tb[1, \u0026#34;Name\u0026#34;] 或 tb$Name 資料類型轉換 預設將字串轉換為因子 不會自動轉換字串 輸出格式 完整列印，可能過多 友好格式，適合大數據 結構查看 str(df) glimpse(tb) 使用dplyr與Tibble結合 data frame 也可以用dplyr串接，但是tibble的設計可以讓整體更簡潔。使用dplyr操作時，特別是在篩選filter和分組group_by中處理字串數據時更加直觀。 支持非標準列名：Tibble 支持包含空格或特殊字符的列名，而Data Frame通常需要更複雜的處理。 # 載入 tidyverse library(tidyverse) # 篩選年齡大於27的資料 filtered_tb \u0026lt;- tb %\u0026gt;% filter(Age \u0026gt; 27) # 新增一欄，計算加權分數 tb \u0026lt;- tb %\u0026gt;% mutate(Weighted_Score = Score * 0.9) # 排序 tb \u0026lt;- tb %\u0026gt;% arrange(desc(Age)) tb \u0026lt;- tibble( \u0026#39;Name A\u0026#39; = c(\u0026#34;John\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;), Age = c(25, 30, 28), Score = c(85.5, 92.0, 78.5) ) #tibble可以允許中間有空格的column name，但是data frame則會自動將空格縮成.，會導致錯誤 tb$`Name A` 關於tidyverse的部分，後續我會專門做介紹。\n課程小結 資料類型 特性 範例 Data Frame 行列結構，row內類型一致，column間可不同 data.frame(Name, Age, Score) Tibble 現代化 Data Frame，靈活且友好 tibble(Name, Age, Score) ","date":1733356800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1733356800,"objectID":"eeb49d8422bc6e2912fa1a56850f3f09","permalink":"http://localhost:56953/post/minicourse_r2/","publishdate":"2024-12-05T00:00:00Z","relpermalink":"/post/minicourse_r2/","section":"post","summary":"","tags":["R","coding"],"title":"迷你課程:R語言-2~Dataframe與tibble","type":"post"},{"authors":["戴揚紘",""],"categories":["R語言迷你課程"],"content":"Quick look 今天介紹R的data type:\nAtomic vector Vector List Matrix Array Atomic vector Atomic Vector 是 R 中最基本的資料類型之一，它只能包含相同類型的資料，例如數字、字串或布林值。\n種類:\nNumeric（數值） Character（字串） Logical（布林值） Integer（整數） Complex（複數） Atomic vector可以很容易地用c(...)來建構起向量。\nAtomic vector的建立與操作 # 建立不同類型的 Atomic Vector numeric_vec \u0026lt;- c(1.5, 2.3, 4.8) # 數值向量 integer_vec \u0026lt;- c(1L, 2L, 3L) character_vec \u0026lt;- c(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;) # 字串向量 logical_vec \u0026lt;- c(TRUE, FALSE, TRUE) # 布林向量 # 查看資料類型 class(numeric_vec) class(character_vec) class(logical_vec) 我們可以針對atomic vector做一般的向量操作。而布林值的運算會先被轉成integer，再做加總。\n# 向量操作 numeric_vec * 2 # 每個元素乘以2 character_vec[1] # 獲取第一個元素 sum(logical_vec) # 計算布林值的數值總和 (TRUE = 1, FALSE = 0) sum(logical_vec) 中的運算涉及coercion(類型強制轉換)，因為布林值(TRUE 和 FALSE) 被自動轉換為數值(1 和 0))來進行數學運算。\n而向量有許多特性：\nlength(): 會得到向量長度。 names(): 會得到向量名稱。 而R有一個特殊的函式叫replacement function，也就是很多函式都可以藉由指派的方式改變某內容特徵：\nnames(vector)\u0026lt;- c(\u0026#39;Jackson\u0026#39;, \u0026#39;Joseph\u0026#39;, \u0026#39;Joanne\u0026#39;) 這個在日後的數據處理非常常用，需要牢記。\n何謂coercion? Coercion是R中將一種資料類型自動轉換為另一種類型的過程。在這個例子中，邏輯型(logical)被轉換為數值(numeric)。\n如果不小心將不同的data type用c(...)存到vector中，R會自動Coercion，並轉成higher type。而何謂higher type? R會依據下列的排序來將資料型態轉換為其中比較高階的類別：\nlogical\u0026lt;integer\u0026lt;double\u0026lt;complex\u0026lt;character\n而R也有一寫好用的manual coercion函式，如as.開頭的：\nas.integer() as.character() as.double() as.complex() 另外要使用迴圈時可以使用as(c(x,x,x), \u0026#39;character\u0026#39;)來轉換S4物件內之元素，比較方便。\nList List 是一種可以容納不同資料類型或結構的容器，例如數字、字串、甚至是向量或矩陣。是一種non-atomic vector，且儲存過程不會產生coercion。\nList的建立與操作 # 建立一個 List my_list \u0026lt;- list( name = \u0026#34;John\u0026#34;, age = 25, scores = c(85, 90, 78) ) # 查看 List 中的元素 my_list$name my_list$scores[2] # 第二個成績 注意上面的my_list存了三個不同型態的元素，而且都賦予一個名稱。List的名稱可以用$取出來。如：\nmy_list$name #\u0026gt; $name [1] \u0026#34;John\u0026#34; 也可以用雙括號[[1]]的方式取出來：\nmy_list[[1]] #\u0026gt; [1] \u0026#34;John\u0026#34; 這邊注意，在R裡面[[]]與[]取出的內容是不同的:\n[]會返回元素，但保持原來的結構。 [[]]會返回元素，但會移除結構。 簡單來說就是用[]取出的東西會維持list的型態，但是用[[]]取出的東西則屬於那個元素的型態，如果是John，那就是character型態。\nMatrix Matrix 是一種二维的atomic vector，必須有相同的資料類型。\nMatrix的建立與操作 可以用dim()來將向量轉變成矩陣\na \u0026lt;- 1:8 dim(a) \u0026lt;- c(4,2) 會得到\n#\u0026gt; [,1] [,2] [1,] 1 5 [2,] 2 6 [3,] 3 7 [4,] 4 8 而若是將矩陣的dimension attribute刪除，會將矩陣復原為向量。如：\n#復原成向量 dim(a) \u0026lt;- NULL 也可以直接用matrix()來建立矩陣。\n# 建立矩陣 my_matrix \u0026lt;- matrix(1:9, nrow = 3, ncol = 3) # 3x3 矩陣 # 取出元素 my_matrix[2, 3] # 第二row第三column的元素 # 矩陣操作 my_matrix * 2 # 每個元素乘以2 rowSums(my_matrix) # 計算每行的總和 colMeans(my_matrix) # 計算每列的平均值 另外R有一個特殊的回收概念，就是當給的元素數量低於要求時，會依狀況重複出現：\nmatrix(1:3,3,4) #\u0026gt; [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 2 2 2 2 [3,] 3 3 3 3 Array Array 是多維的數據結構，可以看作是矩陣的擴展。\nArray的建立與操作 # 建立三維陣列 my_array \u0026lt;- array(1:12, dim = c(2, 3, 2)) # 2x3x2 陣列 #\u0026gt; , , 1 [,1] [,2] [,3] [1,] 1 3 5 [2,] 2 4 6 , , 2 [,1] [,2] [,3] [1,] 7 9 11 [2,] 8 10 12 # 查看元素，注意第幾層是放在最後一個 my_array[1, 2, 2] # 第2層中的第1row第2column的值 #\u0026gt; [1] 9 # 查看維度 dim(my_array) #\u0026gt; [1] 2 3 2 其他特殊值 NA: 表示missing value，是一種place holder，會顯示出來。 NULL: 是一種長度為0的物件，與NA不同，無法印出來，在需要刪除某些物件的時候可以派上用場。 Inf, -Inf: 也是一種place holder。 課程小結 資料類型 特性 範例 Atomic Vector 單一類型元素，1D c(1, 2, 3) List 不同類型元素，1D list(a = 1, b = \u0026#34;text\u0026#34;) Matrix 相同類型元素，2D matrix(1:6, nrow = 2, ncol = 3) Array 相同類型元素，多維 array(1:12, dim = c(2, 3, 2)) ","date":1733270400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1733270400,"objectID":"a918e657c6ee6840aebfcec42707fa66","permalink":"http://localhost:56953/post/minicourse_r1/","publishdate":"2024-12-04T00:00:00Z","relpermalink":"/post/minicourse_r1/","section":"post","summary":"","tags":["R","coding"],"title":"迷你課程:R語言-1~R的資本資料型態","type":"post"},{"authors":["戴揚紘",""],"categories":["單細胞定序"],"content":"10x Genomics 推出的Single Cell GEM-X技術為單細胞分析開創了嶄新的可能性，提供前所未有的效能提升。基於這項創新，10x Genomics進一步推出了GEM-X Flex和，為研究者提供更靈活、高效且經濟的實驗設計選擇，跟先前的Flex protocol相比，GEM-X Flex可以在花費較少的情況下，用較少的細胞數量，得到品質更好的數據。\n","date":1733184000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1733184000,"objectID":"849988860235a9ff64450272d2b3881d","permalink":"http://localhost:56953/tech/tech1/","publishdate":"2024-12-03T00:00:00Z","relpermalink":"/tech/tech1/","section":"tech","summary":"10x Genomics 推出的Single Cell GEM-X技術為單細胞分析開創了嶄新的可能性，提供前所未有的效能提升。基於這項創新，10x Genomics進一步推出了GEM-X Flex和，為研究者提供更靈活、高效且經濟的實驗設計選擇，跟先前的Flex protocol相比，GEM-X Flex可以在花費較少的情況下，用較少的細胞數量，得到品質更好的數據。\n","tags":["single cell sequencing"],"title":"10X Genomics 推出GEM-X Flex","type":"tech"},{"authors":["戴揚紘","李定頡"],"categories":["腎臟病學"],"content":"Quick look IgA腎病變(IgA nephropathy, IgAN)是一種常見的原發性腎絲球腎炎，雖然進程緩慢，但仍有不少患者在會一生中面臨腎衰竭或是洗腎的風險。該疾病的致病機轉主要來自於黏膜免疫系統中衍生的缺半乳糖化IgA1在血液中濃度升高，且和特異性IgG和IgA抗體結合，形成免疫複合物沉積於腎小球內，導致發炎、補體活化及腎損傷。儘管現有的治療選擇有限，但不同類型的療法正在快速發展，本篇針對最新發表在nature review nephrology的文章，深入探討IgAN的病生理機制與治療前景。\n前情提要 IgAN最早於1968年由Jean Berger與Nicole Hinglais提出，其特徵為腎絲球間質中出現IgA沉積。 IgAN與IgA血管炎在腎臟病理學上無法區分，但後者會影響其他器官如皮膚、關節、胃腸道。 IgAN的年發病率估計為每10萬成年人中至少2.5例，實際數據因不同因素而被低估。 患病率有明顯的地域差別(圖一)：東亞地區高達40-50%，而北美、歐洲分別為10-20%及20%，而非洲則少於5%。男性患者比例在歐美地區明顯偏高(約2:1)，亞洲則為1:1。 雖然部分患者病程較為良性，但大多數患者需要長期治療以減緩腎功能下降，而現有標準治療對疾病的控制有限。 IgAN對患者及其家庭，以及全球各地的醫療體系帶來重大負擔。因此開發安全且有效的長期療法刻不容緩。 圖一 造成IgAN的關鍵?何謂多打擊假說? IgA1抗體鉸鏈區(hinge region)上O-glycan側鏈若缺少半乳糖(galactose)，也稱為galactose deficient IgA1(Gd-IgA1)已知是IgAN的主要根源，但光有這個變異還不夠，因為IgAN病人的一級親屬即使在血液中有高濃度的血清Gd-IgA1，也不一定會發病。而目前研究顯示，至少需要四個事件的發生(不一定是獨立事件)，才有機會產生臨床症狀，並診斷為IgAN(圖二):\n血液中出現Gd-IgA1(Hit1)。 血液中出現對抗Gd-IgA1的IgA或IgG自體免疫球蛋白(Hit2)。 Gd-IgA1容易聚集在一起，吸引其他血清蛋白，並與自體免疫球蛋白形成免疫複合體(Immune complex)(Hit3)。 繫膜細胞(mesangial cell)增生及堆積，並對腎絲球產生傷害(Hit 4)。 而繫膜細胞的堆積會導致細胞激素(cytokine)的分泌、補體(complement)的活化、足細胞(podocyte)受傷、腎絲球過濾出問體等等，從血尿、蛋白尿、腎小管纖維化，進展到最終腎功能的喪失。\n圖二 IgA的抗體分型有什麼其妙之處？ IgA可分為兩種類型：根據是否具有延伸的鉸鏈區分為IgA1和IgA2。IgA主要由黏膜淋巴組織(mucosa-associated lymphoid tissue, MALT)分泌，其中腸道淋巴組織(gut-associated lymphoid tissue, GALT)是IgA的主要來源。\n那麼，IgA究竟在免疫系統中扮演什麼角色呢？當腸道中出現非共生(commensal)的病原體時，巨噬細胞或M細胞會將抗原呈現給T細胞，直接或間接地刺激黏膜下的B細胞產生抗體。在這個過程中，需要一些協同的刺激訊號，特別是B細胞活化因子(B cell activating factor,BAFF)和增殖誘導配體(a proliferation-inducing ligand, APRIL)在獨立於T細胞(T cell-independent)的抗體生成中起關鍵作用。然而，活化的B細胞並不會立即在黏膜下分泌IgA，而是先移動到中心淋巴結進行進一步的成熟和改變。\nIgA+ B細胞從MALT離開，經由淋巴系統和循環系統遷移至中央淋巴結，在那裡進一步分化。 IgA+ B細胞回到黏膜固有層，在那裡成熟為分泌抗體的漿細胞(plasma cells)。 漿細胞主要分泌聚合型IgA(pIgA），這種分子形式由至少兩個IgA單體通過J鏈連接而成，J鏈是一種17kDa的蛋白，通過二硫鍵將α-重鏈上的半胱氨酸殘基連接。 pIgA在黏膜上皮細胞的基底外側表面與聚合型Ig受體(pIgR)結合，並進行跨細胞移動至管腔面。 在黏膜表面，pIgR被酶切割，其中一部分受體仍與pIgA結合，成為分泌成分，從而形成分泌型IgA(sIgA)。 需要注意的是，這邊分秘的IgA為antigen-specific，會在腸道免疫反應發生後於循環中上升，與本來在循環中的單體IgA不同(由骨髓B細胞分秘)。由此可見IgA的分泌是系統性免疫反應中很重要的一部分。\nIgA1鉸鏈區的混亂？ 在IgA1分子中，有一個特別的結構叫做鉸鏈區域，位於α重鏈的第一和第二區之間。這裡有18個氨基酸，可以進行轉譯後的修飾，在蘇胺酸(threonine)及絲胺酸(serine)上加上一個糖基(圖三)。而這項修飾目的是要防止微生物蛋白酶對這個區域進行降解。\n在IgA1分子中，9個潛在的糖基化位點中通常有3到6個會被修飾：\n由N-乙醯半乳糖胺轉移酶2(GalNAcT2)添加N-乙醯半乳糖胺(GalNAc)。 核心1β-1,3-半乳糖基轉移酶(C1GalT1)在輔助下，將半乳糖與GalNAc結合，完成主要的修飾。 唾液酸(Sialic acid)被加入，為分子提供更強的防護，防止後續修飾。 其實，微生物的影響也不可忽視，一些微生物釋放的PAMPs(Pathogen-associated molecular patterns)會促使IgA1半乳糖化的程度減少，讓鉸鏈區對微生物蛋白酶失去招架的能力。\n為什麼會出現這些異常？研究發現，基因的因素及腸道黏膜的環境都有可能造成C1GalT1活性下降或是GalNAc唾液酸化的增加，減少半乳糖化，促使更多的Gd-IgA1產生。\n半乳糖化的程度減少似乎沒有想像中的可怕，但可怕的是Gd-IgA1會有和彼此之間形成聚合物的傾向，並和一堆血清蛋白結合。這種狀況下產生的免疫複合物還會激活補體系統，誘發一連串的發炎反應。\n圖三 源源不絕的Gd-IgA1 Gd-IgA1的來源可能涉及兩個主要的來源：黏膜和骨髓。目前許多證據支持黏膜是主要來源，因為IgAN的病情嚴重程度與黏膜感染密切相關。例如，在小鼠模型中，使用廣效抗生素清除腸道菌群可以有效防止IgA在腎絲球中的沉積。而在另一項實驗中(針對 BAFF過表達小鼠，這類小鼠會產生自發性類IgAN疾病)，將小鼠飼養於無菌環境下，能有效阻止腎絲球IgA的沉積。此外，研究發現IgAN患者在上呼吸道感染時，循環中的IgA+B細胞數量顯著增加，進一步支持黏膜作為Gd-IgA1主要來源的假說。\n黏膜來源的IgA1常為聚合型，且O-糖基化不足，與IgAN患者循環中以及腎絲球中沉積的Gd-IgA1極為相似。然而，一些黏膜衍生的B細胞可錯位至骨髓，並在那裡產生致病性Gd-IgA1。與健康人相比，IgAN患者骨髓中含有比例更高的漿細胞，這些細胞能分泌二聚體(dimeric)IgA1。總結來說，黏膜和骨髓都可能是病理性IgA的重要來源。\n免疫複合體集結！ IgAN患者的病理性Gd-IgA1主要以高分子量免疫複合物形式存在，這些複合物由抗Gd-IgA1的IgG或IgA抗體結合而成，其形成與遺傳因素(如HLA多型性)和環境因素密切相關。在環境因素的部分，微生物可能會在細胞表面的多醣體表現GalNAc motif，而B細胞會因此被激活而分泌對抗這個motif的IgA與IgG，並會直接和裸露出來的鉸鏈區域結合，與Gd-IgA1形成複合物。\nIgA-IgG免疫複合物的生成與IgAN的活性有密切關係。研究顯示，在兒童IgA血管炎中，只有伴隨腎炎的患者會出現升高的IgA–IgA和IgA–IgG免疫複合物。而在IgAN患者中，抗Gd-IgA1的IgG抗體(特別是IgG1和IgG3亞型)顯著升高，並在疾病活躍期進一步增加。這些抗體沉積於腎絲球間質，與疾病的嚴重程度及腎功能惡化密切相關。\n進一步研究發現，高分子量的Gd-IgA1免疫複合物會刺激腎間質細胞增殖，而單一的Gd-IgA1無此作用。同樣地，如果自體抗體被換成IgA，也不會產生類似影響。此外，血清中IgA濃度與Gd-IgA1濃度之間沒有相關性，也沒有直接證據顯示IgA與疾病進展有關。總結而言，抗Gd-IgA1的IgG免疫複合物不僅促進了腎炎的發展，還可能成為IgAN嚴重程度的重要指標。\n此外，循環中的Gd-IgA1免疫複合物在肝臟分解時受到阻礙。其原因包括高分子量降低了免疫複合物與Kupffer細胞的接觸機會，加上免疫複合物對肝臟去唾糖蛋白受體(asialoglycoprotein receptor, ASGPR)的結合能力下降，該受體負責識別IgA1鉸鏈區域中的末端半乳糖分子。這些清除障礙導致更多的Gd-IgA1免疫複合物運輸到腎絲球，最終在腎小球間質內沉積並累積，加重病情。\n繫膜細胞的堆積 Gd-IgA1在腎絲球的堆積與清除其實是一個動態過程，當含有IgA堆積的腎臟移植給另外一個沒有IgAN的病人時，在後續的腎切片可以觀察到IgA被清除。而在腎絲球堆積的IgA會和繫膜細胞作用，導致不同程度的發炎與纖維化。目前針對到底是哪個繫膜細胞表面上的接受器會和IgA作用還沒有定論，但小鼠實驗發現IgA免疫複合物需要sCD89與tissue transglutaminase 2來成功激活繫膜細胞。\n在IgA沈積在腎絲球後，一系列的發炎反應接連產生(圖四)，包含繫膜細胞的增生、促發炎及促纖維化細胞素的分泌、生長因子分泌以及細胞外組織的重塑。這一系列的發炎反應牽涉了pIgA在其中的影響。在實驗中，pIgA對繫膜細胞的親和力大，並且會導致IL8的分泌。而pIgA的N-glycan也與單體IgA(mIgA)不同，會透過lectin路徑對補體系統產生更多的刺激。此外，繫膜細胞在刺激後產生的各種細胞激素造成了足細胞的傷害，進一步導致蛋白尿、腎小管萎縮、間質纖維化與過濾率下降等臨床症狀。\n圖四 補體系統活化 在九成的IgAN患者中，補體成分C3與IgA會共同沉積於腎絲球中，而C3的缺失則通常表示較為緩和的病程。此外，有時候會觀察到膜攻擊複合物(membrane attack complex, MAC)的沉積，這通常也與較差的預後相關。研究發現，在IgAN患者中，循環中的C3水平可能降低，而相應的C3降解片段會升高，這表示除了腎臟內補體活化外，還可能存在全身性的補體活化。\n由於C1q的沉積非常罕見，顯示補體活化的經典路徑並非IgAN的主要致病機制。相較之下，替代路徑和凝集素路徑在IgAN的病程中發揮了重要作用。在替代路徑中，properdin和補體因子H相關蛋白(FHR)的沉積與疾病的進展性病程密切相關；然而，CFHR3和CFHR1基因的缺失則對疾病有保護作用。華人族群中CFHR3和CFHR1缺失的頻率較低，這可能解釋為何該族群更易出現腎絲球發炎性的病變。\n另一方面，凝集素路徑中的成分，如甘露聚糖結合凝集素(MBL)和MBL相關的絲氨酸蛋白酶(MASP)，在部分患者的腎絲球中沉積，進一步加重了腎損傷。這些發現表明，補體系統的激活在IgAN中呈現多層次且複雜的作用機制，並對疾病的進展和預後產生深遠影響。\n遺傳機制 IgAN和其他許多疾病一樣也有著複雜的遺傳因素，在近年，Genome-wide association studies(GWAS)已經成為一項不用透過假設推論來探索複雜的遺傳機制的重要工具。在歐洲與東亞的許多GWAS計畫已經發現了30個獨立的高風險位點，約有11%的疾病風險可以用這些位點來解釋，因此也可以部分解釋為何IgAN會有區域上的差異。\n有問題的GWAS位點主要出現在跟IgA製造、免疫調控與維護腸道黏膜完整性相關的基因上，而這些位點也出現在類風濕性關節炎、甲狀腺低下及氣喘等疾病上，表示這些疾病共享了這些多基因性的性狀(polygenic architecture)。\nIgAN的臨床和病理特徵多樣，可能是不同致病途徑匯聚的結果。多重打 …","date":1732838400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1732838400,"objectID":"2b3b20cba5aad673822b7c423ecb29cd","permalink":"http://localhost:56953/post/iga_nephropathy/","publishdate":"2024-11-29T00:00:00Z","relpermalink":"/post/iga_nephropathy/","section":"post","summary":"","tags":["Nephrology","IgA nephropathy","immune complex"],"title":"IgA腎病變：現況與挑戰","type":"post"},{"authors":["戴揚紘",""],"categories":["生物資訊"],"content":"Quick look 數年前我還是住院醫師的時候是直接在UCSC Xena平台下載癌症數據，但整個過程很難流程化， 而2019年發表的UCSCXenaTools解決了這個問題，也讓我在前年分析公開數據時方便許多。 UCSCXenaTools是一個專門用來處理UCSC Xena的基因組數據的R套件。該平台集成了多個公開數據庫(如分析癌症數據一定要知道的TCGA、ICGC、TARGET、GTEx等），提供處理過的數據，便於我們進行數據的篩選、連結、探索及下載。UCSCXenaTools的功能強大且操作簡單，在我們先前的preprint發表我也是利用這個套件做TCGA數據的處理，所以這邊就簡單分享我是如何用這個套件來進行分析的。\n簡介 UCSCXenaTools 通過多個Xena Hubs提供對各類公共基因組數據庫的訪問，這些數據經過規範化處理，支持用戶輕鬆地篩選、探索、下載並應用於進一步分析。目前支持的數據中心包括：\nUCSC Public Hub TCGA Hub GDC Xena Hub ICGC Xena Hub Pan-Cancer Atlas Hub Toil RNAseq Hub 等。 我們可以通過函數如 XenaGenerate()、XenaFilter() 等組合進行操作，並結合其他R套件(如 dplyr)來靈活的處理數據。 實際操作流程 詳細的操作流程可以參考發表在STAR Protocols的這篇，裡面詳細的解釋了每一個步驟以及預期的結果。這邊僅針對基本的操作做介紹:\n安裝及載入 install.packages(\u0026#34;UCSCXenaTools\u0026#34;) library(UCSCXenaTools) 查看可用的所有數據 #載入XenaData到workspace data(XenaData) #查看 head(XenaData) 這邊輸出的XenaData為一個tibble data frame，包含了所有數據的基本資料，也可以透過這個Xenabrowser的網址來對照。\n基本操作函數 生成數據框: XenaGenerate df = XenaGenerate(subset = XenaHostNames == \u0026#34;tcgaHub\u0026#34;) %\u0026gt;% XenaFilter(filterDatasets = \u0026#34;clinical\u0026#34;) %\u0026gt;% XenaFilter(filterDatasets = \u0026#34;OV\u0026#34;) 每一項參數都需要對應到XenaData中的column name\n搜尋感興趣的數據: XenaScan x = XenaScan(pattern = \u0026#39;Blood\u0026#39;) %\u0026gt;% XenaGenerate() 下載數據: XenaQuery XenaQuery(df) %\u0026gt;% XenaDownload(destdir = \u0026#39;Data\u0026#39;) #記得改路徑 操作範例 接下來針對大腸癌的資料來舉例:\n下載TCGA和GTEx數據進行基因表達分析 這邊有一個很重要的概念，根據這篇論文，Xenabrowser上某癌症類別的數據中，Solid Tissue Normal為切除腫瘤附近的健康組織，然而分析時卻發現這類組織的狀態處於真正的健康組織與腫瘤組織之間，所以如果要做差異性基因分析，不要使用下載下來的Solid Tissue Normal來當成Healthy control，而需要用GTEx上下載的資料來當對照。\n# 從 Toil Hub 選擇基因表達數據 GeneExpectedCnt_toil = XenaGenerate(subset = XenaHostNames == \u0026#39;toilHub\u0026#39;) %\u0026gt;% XenaFilter(filterCohorts = \u0026#39;TCGA TARGET GTEx\u0026#39;) %\u0026gt;% XenaFilter(filterDatasets = \u0026#39;TcgaTargetGtex_gene_expected_count\u0026#39;) XenaQuery(GeneExpectedCnt_toil) %\u0026gt;% XenaDownload(destdir = \u0026#39;Data\u0026#39;) #記得改路徑 上面的操作直接下載了一個已經經過處理過的合併數據集，包含了TCGA、TARGET以及GTEx的基因資料，而RNA-seq數據已經對hg38基因組做過排序，並用RSEM及Kallisto方法來做量化。\n下載TCGA臨床數據 paraCohort = \u0026#39;TCGA Colon Cancer\u0026#39; paraDatasets = \u0026#39;COAD_clinicalMatrix\u0026#39; Clin_TCGA = XenaGenerate(subset = XenaHostNames == \u0026#39;tcgaHub\u0026#39;) %\u0026gt;% XenaFilter(filterCohorts = paraCohort) %\u0026gt;% XenaFilter(filterDatasets = paraDatasets) XenaQuery(Clin_TCGA) %\u0026gt;% XenaDownload(destdir = \u0026#39;Data\u0026#39;) #記得改路徑 下載TCGA存活數據 Surv_TCGA = XenaGenerate(subset = XenaHostNames == \u0026#39;toilHub\u0026#39;) %\u0026gt;% XenaFilter(filterCohorts = \u0026#39;TCGA TARGET GTEx\u0026#39;) %\u0026gt;% XenaFilter(filterDatasets = \u0026#39;TCGA_survival_data\u0026#39;) XenaQuery(Surv_TCGA) %\u0026gt;% XenaDownload(destdir = \u0026#39;Data\u0026#39;) #記得改路徑 下載GTEx phenotype數據 Pheno_GTEx = XenaGenerate(subset = XenaHostNames == \u0026#39;toilHub\u0026#39;) %\u0026gt;% XenaFilter(filterCohorts = \u0026#39;TCGA TARGET GTEx\u0026#39;) %\u0026gt;% XenaFilter(filterDatasets = \u0026#39;TCGATargetGTEx_phenotype\u0026#39;) XenaQuery(Pheno_GTEx) %\u0026gt;% XenaDownload(destdir = \u0026#39;Data\u0026#39;) #記得改路徑 重新處理TCGA與GTEx的樣本名稱 filterGTEx01 = fread(\u0026#39;Data/TcgaTargetGTEX_phenotype.txt\u0026#39;) names(filterGTEx01) = gsub(\u0026#34;\\\\_\u0026#34;, \u0026#34;\u0026#34;, names(filterGTEx01)) #將有_的部分去掉 paraStudy = \u0026#39;GTEX\u0026#39; paraPrimarySiteGTEx = \u0026#39;Colon\u0026#39; paraPrimaryTissueGTEx = \u0026#39;^Colon\u0026#39; filterGTEX02 = subset(filterGTEx01, study == paraStudy\u0026amp; primarysite == paraPrimarySiteGTEx \u0026amp; grepl(paraPrimaryTissueGTEx, filterGTEx01$\u0026#39;primary disease or tissue\u0026#39;)) filterTCGA01 = fread(paste0(\u0026#39;Data/\u0026#39;,paraDatasets)) names(filterTCGA01) = gsub(\u0026#34;\\\\_\u0026#34;, \u0026#34;\u0026#34;, names(filterTCGA01)) paraSampleType = \u0026#39;Primary Tumor\u0026#39; paraPrimarySiteTCGA = \u0026#39;Colon\u0026#39; paraHistologicalType = \u0026#39;Colon Adenocarcinoma\u0026#39; filterTCGA02 = subset(filterTCGA01, sampletype == paraSampleType\u0026amp; primarysite == paraPrimarySiteTCGA \u0026amp; grepl(paraHistologicalType, filterTCGA01$histologicaltype)) 合併TCGA與GTEx數據 filterExpr = c(filterGTEX02$sample, filterTCGA02$sampleID, \u0026#39;sample\u0026#39;) ExprSubsetBySamp = fread(\u0026#39;Data/TcgaTargetGtex_gene_expected_count\u0026#39;, select = filterExpr) 只取protein-coding基因來分析 先從這裡下載完整的protein-coding gene資訊。以及在這邊下載ID/gene mapping。\nprobemap = fread(\u0026#39;zz_gencode.v23.annotation.csv\u0026#39;, select = c(1,2)) #只留前兩欄 exprALL = merge(probemap, ExprSubsetBySamp, by.x = \u0026#39;id\u0026#39;, by.y = \u0026#39;sample\u0026#39;) genesPC = fread(\u0026#39;zz_gene.protein.coding.csv\u0026#39;) exprPC = subset(exprALL, gene %in% genesPC$Gene_Symbol) #移除重複基因 exprFinal = exprPC[!(duplicated(exprPC$gene) | duplicated(exprPC$gene, fromLast = TRUE)),] #存檔，作為後續分析使用 write.csv(exprFinal, \u0026#39;00_ExpectedCnt.csv\u0026#39;) 準備臨床資料 這邊我們取腫瘤的淋巴管侵犯的特徵來分析。\nnames(filterTCGA02) #keep \u0026#34;Lymphatic invasion\u0026#34; varClinKeep = c(\u0026#39;sampleID\u0026#39;, \u0026#39;lymphaticinvasion\u0026#39;) clinDF01 = as.data.frame(do.call(cbind, filterTCGA02)) #因為filterTCGA02屬於data.table，可以用do.call() clinFinal = clinDF01[varClinKeep] 找尋缺值的數據，補NA colSums(clinFinal == \u0026#34;\u0026#34;) colSums(is.na(clinFinal)) NA -\u0026gt; clinFinal[clinFinal==\u0026#39;\u0026#39;] colSums(is.na(clinFinal)) table(clinFinal$lymphaticinvasion) 將Yes/No 替換成1/0，以用作後需分析使用 clinFinal$lymphaticinvasion = if_else(clinFinal$lymphaticinvasion == \u0026#39;YES\u0026#39;, 1,0, missing = NULL) table(clinFinal$lymphaticinvasion) 到此終於告一段落啦，後面就可以無痛進行差異性基因分析或是WGCNA了！\n結論 UCSCXenaTools是一個功能強大且靈活的工具，讓我們能夠在癌症基因組研究的道路上如虎添翼。在處理TCGA、GTEx 等大規模基因數據時，這個套件不僅簡化了繁瑣的數據篩選和整合流程，還提供了強大的數據搜索和下載功能，極大地提升了分析效率。\n這樣的數據處理方法不僅適用於大腸癌研究，還能靈活地應用於其他癌症類型，甚至還可以下載近年十分熱門的單細胞數據。\n","date":1732752000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1732752000,"objectID":"cfc4596d57a1f35b860721a49c6f72c5","permalink":"http://localhost:56953/post/ucscxenatool/","publishdate":"2024-11-28T00:00:00Z","relpermalink":"/post/ucscxenatool/","section":"post","summary":"","tags":["Bioinformatics","data science","cancer","R"],"title":"生資硬核技術：公開癌症基因數據下載及操作","type":"post"},{"authors":["戴揚紘",""],"categories":["免疫治療"],"content":"Quick look 腫瘤內部的免疫微環境基本上都存在高度異質性，從免疫細胞密集分布到完全缺乏等等。目前的證據顯示，腫瘤抗原特異性T細胞(Tumor-specific T cell)若要順利的啟動及維持他們的活性，仰賴腫瘤引流淋巴結(tumor draining lymph node)和腫瘤組織內的微環境，特別是三級淋巴結構（tertiary lymphoid structure，TLS），其通常位於腫瘤邊緣並由B細胞主導。而TLS中的B細胞活性也與Immune checkpoint inhibitor的成功率息息相關。\n這些免疫細胞由專門的纖維母細胞(如T細胞區網狀細胞和血管周圍網狀細胞)支撐，而這之間的交互作用也從TLS透過某種物理架構延伸到腫瘤內部。本篇研究通過單細胞轉錄組學和高解析度顯微技術，發現了在肺癌中形成特定T細胞環境的纖維母細胞亞群(fibroblastic reticular cell)。這些FRC與免疫細胞的互動促進了TLS的形成、T細胞軌跡中的分化，以及控制T細胞活性。實驗顯示，破壞腫瘤微環境中FRC與免疫細胞的互動會降低CD8+ T細胞的抗腫瘤活性並促進腫瘤生長。\n由此可見，特定的FRC亞群通過提供增長和分化的信號，在腫瘤內部支持保護性免疫反應(protective immunity)，對抗腫瘤生長。\nFRC細胞與肺癌腫瘤內部T細胞關係不尋常？ 對肺癌來說，有肋膜侵犯是一項不好的預後因子，而研究也發現，由subpleural region(Subpleural margin, SM，有肋膜侵犯的部分)切下的腫瘤，與位於central(central margin, CM，同一塊腫瘤，靠近中心的部分)的腫瘤在免疫細胞的組成上有顯著個差異。SM腫瘤的淋巴細胞比較鬆散，而且主要位於腫瘤周圍，但CM腫瘤內部有明顯的T細胞浸潤(圖一)。團隊也發現CM腫瘤T細胞附近充滿ACTA2陽性的纖維母細胞，而這些細胞與SM相比，與吸引T細胞有關的chemokine基因CCL19與CCL21之表現亮顯著較高。\n圖一 近一步用高解析顯微鏡發現，腫瘤內的T細胞棲息區(niche)，與腫瘤TLS有連結，而CCL19+ FRC更是與T細胞有接觸，而FRC表現的CCL19量的多寡也形成了一條T細胞依循的梯度(gradient)，由此可見CCL19+ FRC似乎主導了腫瘤內T細胞的遷移。\n探索其中的分子機制 精細的交互作用 團隊使用螢光顯微鏡擷取圖片並重組成3D影像，發現在TLS中的CCL19+ POSTN+ PDPN+ 的FRC與T細胞有緊密的接觸，同樣的情形也在CM中血管附近的FRC出現。而利用scRNA-seq分析免疫細胞的interactome也發現，腫瘤內的PRC(perivascular reticular cell)與TRC(T cell zone reticular cell)主要跟CD8+ T細胞作用(圖二)。團隊利用CellChat分析CCL19+FRC與CD8+T細胞之間的通訊涉及以下信號：\n遷移信號：CXCL12和CXCL16。 細胞間的黏附：VCAM1。 激活因子：包括type II interferon。 微環境因子：如LTBR、TNFRSF14和NOTCH3，為CD8+T細胞創造適合的微環境。 總結來說，CCL19+TRCs和PRCs與CD8+T細胞的互動通過一系列信號網絡調節，形成特定的纖維母性微環境，進一步支持T細胞的功能活化和發育。\n圖二 FRC分化路徑 團隊發現除了cancer-associated fibroblast(CAF)會表達CCL19之外，正常肺組織的mural細胞與adventitia細胞也會表現CCL19。因此作者合理懷疑表現CCL19的PRC與TRC來自於血管周圍的纖維母細胞。團隊使用分化路徑分析(differentiation trajectory analysis)後也證實mural細胞會衍生成為PRC；而adventitia細胞會於TRC路徑的根部(圖三)。而團隊進一步使用小鼠肺癌模型(Lewis lung carcinoma expressing the viral glycoprotein peptide 33 of the lymphocytic choriomeningitis virus)也支持這項發現。\n圖三 小鼠模型也能出現TLS? 根據先前的研究，藉由病毒激活的CD8+T細胞會在發炎組織中形成TLS，因此團隊在小鼠植入肺腫瘤細胞後在第15天接受疫苗注射，此疫苗設計為重組冠狀病毒的質體，可以表現LCMV glycoprotein gp33與myeloid cell stimulating factor Flt3l。在施打疫苗後，腫瘤成功出現腫瘤邊緣與腫瘤內部的TLS，而在小鼠的腫瘤內部的FRC也與CD8+T細胞緊密接觸。\nFRC對CD8+T細胞抗腫瘤的影響？ 研究顯示，腫瘤微環境中的FRC在促進抗腫瘤 CD8+ T細胞免疫中發揮關鍵作用。通過使用白喉毒素(DT)去除小鼠Ccl19-Cre+ 細胞，發現FRC的缺失導致腫瘤失去FRC的網絡，顯著減少腫瘤內CD8+ T細胞的募集，並加速腫瘤生長。同時，腫瘤特異性CD8+ T細胞的效應功能(如 IFN-γ、TNF 和 granzyme B 的產生)以及增殖活性(KI67 表達)均顯著下降，且表現出更高的耗竭標誌(如 PD1、TIM3、KLRG1)。FRC 通過粘附分子(如 ICAM1、VCAM1）、趨化因子（CXCL16）和免疫調節細胞因子（如 TGF-β1、TSLP）與CD8+ T 細胞進行交互，促進其細胞毒性、增殖和分化。總結來說，FRC在腫瘤微環境中透過多重免疫調控途徑增強了抗腫瘤免疫反應，其缺失會削弱T細胞功能並促進腫瘤進展。\n結論 這篇研究揭示，腫瘤微環境中的CCL19表達FRCs在促進抗腫瘤CD8+ T細胞免疫反應中扮演關鍵角色。這些FRCs(包括PRCs和TRCs)形成三維細胞網絡，作為T細胞進入腫瘤實質的“通道”，同時支持T細胞在腫瘤淋巴結(TDLNs)和腫瘤相關淋巴樣結構(TLS)中的活化與擴增。CCL19+ FRCs還維持腫瘤特異性CD8+T細胞的增殖和效應分化，其功能受腫瘤和基質細胞產生的信號調控。這些FRC網絡不僅促進T細胞的遷移，還與患者的良好預後密切相關，未來應致力於探討其他腫瘤類型中FRC的發育途徑，並設計促進PRC/TRC分化的策略，以增強抗腫瘤免疫反應。\n","date":1732665600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1732665600,"objectID":"f207ec30ad238cfec965781d9a03fec0","permalink":"http://localhost:56953/post/paperr3/","publishdate":"2024-11-27T00:00:00Z","relpermalink":"/post/paperr3/","section":"post","summary":"","tags":["Immunotherapy","lung cancer","T cell"],"title":"纖維母性網狀細胞為肺癌中的T細胞塑造碉堡？","type":"post"},{"authors":["戴揚紘",""],"categories":["人工智慧"],"content":"Quick look 人工智慧的快速發展，特別是高靈活性和可重複使用的模型，預計將為醫學領域帶來全新的能力。這篇發表於nature的文章提出了一種新的醫學AI模式，稱為通用型醫學人工智慧(Generalist Medical AI，GMAI)。GMAI 模型將能夠在極少甚至不依賴特定任務標註數據的情況下，執行多樣化的醫學任務。這些模型通過對大規模、多樣性數據集的自監督學習構建，能靈活解讀多種醫學數據模態的組合，包括影像數據、電子健康紀錄(EHR)、實驗室檢驗結果、基因組數據、圖形數據和醫學文本等。GMAI模型的輸出將更具表達性，例如提供自由文本解釋、語音建議或圖像註解，並展現出高級的醫學推理能力。\n基礎模型真的有那麼強大？ 基礎模型(Foundation Models)是最新一代的AI模型，基於大規模、多樣化的數據集訓練，並可用於多種下游任務。 與以往專注於單一任務的AI模型不同，基礎模型具備處理多任務的靈活性和通用性，例如回答文本問題、描述圖像以及玩電子遊戲。\n隨著數據集規模的增長、模型規模的增大以及模型架構的改進，基礎模型讓學界看到了AI強大的潛能。最著名的例子為於2020年發表的GPT-3，藉由通過上下文學習，僅需要提供一些實例或提示(prompts)，就能針對先前未曾訓練過的資料作出判斷。而另一項關於基礎模型的潛能是，這種模型可以同時接受多種類型的數據模態(如圖像、文本)並生成輸出。另如Google DeepMind於2022年發表的Gato模型能夠進行聊天、描述圖像、玩電子遊戲及控制機器臂，被視為通用代理(Generalist Agent)。\n還記得2020 GPT-3第一次公開讓使用者使用時，我在醫院和同事都驚呆了，立馬使用這個強大的聊天機器人來優化我們寫的程式代碼。而現在的發展更為進步、套件更為豐富，已經可以很好的輸出程式碼、生成圖片以及閱讀檔案，只能感嘆AI的迅速發展。\n醫學基礎模型的挑戰 目前的醫學AI模型仍以特定任務為主，缺乏靈活性和通用性。例如胸部X光判讀模型只能檢測肺炎，無法完成完整的放射學報告。 此類模型高度依賴人工標註的數據集，且模型的應用範圍受限於訓練數據的標記。在FDA批准的超過500款臨床醫學AI模型中，大多僅針對1或2個任務，由此可見光靠一兩個模型無法解決所有臨床上的問題，而匯集所有的模型也顯得曠日廢時，不切實際。探究其受限的原因，實在是因為醫學數據集在獲取上有一定的難度，且數據高度多樣化，針對一個癌症病人，不僅要收集影像數據，還要收集所有的臨床資料、甚至是基因組資料，而每一種資料的格式都不同，可想而知整合的困難度。\n然而，近年基礎模型的發展或許可以顛覆我們對醫學AI的認知。此篇文章的團隊提出GMAI(圖一)，期望這種基礎模型將取代目前的特定任務醫學AI模型，成為通用模型。GMAI具有三大關鍵能力：\n動態任務理解：模型只需用簡單的語言描述任務即可執行新問題，無需重新訓練。 多模態輸入輸出：能處理並生成多種數據模態的組合(如影像、文本、實驗室結果等)。 靈活應用於未知問題：GMAI能代表醫學知識，解決未曾明確訓練過的新任務。 圖一 目前現況 其實有用過ChatGPT的醫師都知道，他已經可以通過醫師國考了，而目前在輸入進去某疾病的特徵也通常可以做簡單的鑑別診斷，甚至做出正確的判斷，這都是仰賴我們不斷地輸入以及反饋，這個GPT模型才能越來越好。然而即便如此，針對非文本型態的醫學資料，GPT顯然無法做多模態的協同處理來生成事實陳述，也無法在用戶端提供靈活的互動，讓醫師能藉由介面操作腫瘤的識別。 而針對多模態，GMAI可以整合使用者的輸入，將輸入轉換成token，每個token都代表模態的一小部分，如一句話中的一個字，或是一張圖片的一個角落，而整合的token將代表使用者的輸入，並且可以再用transformer的模型結構做處理，讓GMAI可以針對不同種類的輸入做理解。\n醫學知識 傳統醫學AI模型在訓練之前，通常缺乏對醫學領域的背景知識，僅依賴輸入數據與目標預測之間的統計關係。這種缺乏背景知識的特性，使得在數據稀缺時，訓練模型完成特定醫學任務更加困難。而GMAI可以通過結構化的知識圖譜(knowledge graphs)，可以推理醫學概念及其之間的關係。基於最新的檢索技術(retrieval-based)，GMAI能從現有資料庫（如文章、影像或過去案例）中獲取相關背景，提供上下文支持。GMAI也可提供解釋性預警，例如：「該患者可能會發展為急性呼吸窘迫綜合症，因其近期因嚴重胸部創傷住院，且儘管吸入氧氣濃度增加，但動脈血氧分壓仍持續下降。」當需要提供治療建議時，GMAI模型甚至可推斷並利用醫學概念與臨床發現之間的因果關係，這對其在臨床中的應用至關重要。\n最後一個是解決數據稀缺問題，通過豐富的分子與臨床知識，GMAI能將相關問題的知識轉移到目標任務，進而解決數據有限的任務。一個典型例子是AI在藥物重新定位(drug repurposing)中的應用，可以解決在有限藥物數據庫或是交互作用的資料背景下，提供臨床一個新的方案。\nGMAI的終極優勢!? Controllability GMAI允許用戶細緻控制其輸出格式，使得複雜的醫學信息更加易於理解。例如：模型可以根據需求重新表述自然語言原本的回應。 也可以調整視覺化內容(如改變視角或標註重要特徵)。能根據需求調整輸出中的專業細節程度，甚至翻譯為多種語言，方便與不同背景或是語言的醫師交流。用戶也需要接受正式培訓，以學習如何有效的查詢和使用GMAI的輸出。\nAdaptability 傳統醫學AI模型在技術、環境或人口設定的改變下會有表現不佳的狀況，而GMAI能通過「上下文學習」快速適應。 例如，醫院只需提供少量例子作為提示，就能讓GMAI解讀來自新型X光機器的影像，而傳統模型則需在全新數據集上重新訓練。 另一個有用的應用場景如：GMAI能快速適應新冠病毒的變異株，例如在臨床醫師的提示下，可以將「支氣管和血管周圍浸潤」視為指標，作為「Omicron肺炎」的影像特徵依據，並更新對變異株的認識。\nApplicability GPT-3 作為 AI 基礎模型的成功案例，其發布後幾個月內被應用於超過300個應用程式中。另外如CheXzero可以在不依賴標籤的情況下，檢測胸部X光中的數十種疾病。因此，GMAI將驅動大規模醫學AI模型的開發與應用。這些模型既可直接生成輸出供臨床應用，也可生成中間數值表示作為專業子模型的輸入，用於執行特定任務。然而GMAI的靈活性也可能成為一把雙刃劍，若基礎模型中存在缺陷，這些問題可能會在下游應用中被擴大。\nGMAI現階段的挑戰 Validation 要驗證GMAI其實非常困難，因為它具有多功能且能執行用戶首次設定的全新任務，難以預測所有可能的錯誤模式。現有AI模型只需針對特定任務進行驗證(如腦部MRI診斷特定癌症)，但GMAI涉及更多不可預見的任務場景，也有辦法診斷所有腦部腫瘤，所以我們無法針對每一種疾病去設計驗證。因此開發者和監管機構需解釋GMAI的測試範圍與用途。界面應設計警示功能，以防在未知場景下生成不準確的訊息。\nVerification GMAI 處理的輸入與輸出更為複雜（如結合影像、數據、文本），使其正確性更難由單一專業的醫師來做驗證。與傳統模型相比，GMAI 的輸出可能需要多學科團隊(放射科醫師、病理學家、腫瘤學家等)共同判斷。因此可以引入解釋性技術，例如附上文獻支持的連結，幫助臨床醫師更有效地驗證模型的預測。也要確保模型能準確表達不確定性(uncertainty)，避免生成過度自信的結論。\nSocial bias 先前的醫學AI模型已經證實，在訓練中可能因數據集中於某些患者群體，而產生代表性不足的偏見。而GMAI所需的訓練數據規模和複雜性將使這個偏見的問題更為顯著。因此，模型需經過全面驗證，確保在少數族裔或特定群體中的表現也同樣的好。部署後需持續審核和監督，並鼓勵社群通過獎勵競賽找出潛在偏見或錯誤模式。\nPrivacy GMAI可能暴露敏感的患者數據，而惡意用戶可能通過提示攻擊(prompt attacks)繞過限制，提取敏感信息。所以開發者應當強化數據匿名化並限制單一患者的數據收集量。\nScalability GMAI模型的規模和訓練成本驚人，如GPT-3訓練需數百億標記數據，PaLM模型也耗費數百萬美元購買3000-6000 TPU v4處理晶片。訓練大模型對環境也有巨大影響，每個模型可能產生數百噸的二氧化碳當量。這樣的規模，讓我們不禁思考，到底要多大才夠？最近的一項研究建立了數據集大小與模型大小之間的聯繫，建議數據集的token數量應該是模型參數數量的20倍，以達到最佳的性能。然而，現有的基礎模型即使在較低的token數與參數數比值下也能成功訓練。因此，在開發GMAI模型時，仍然難以確定模型和數據集需要多大，特別是因為所需的規模在很大程度上取決於具體的醫學情境。\nGMAI開發需要大規模醫學數據，但與一般基礎模型不同，這些數據需專注於醫學領域，並滿足匿名化和兼容性要求。即便如此，我們依然能利用現有的基礎模型來做前期的訓練，至少會讓GMAI帶有一些基本的功能。最好的例子就是在大量輸入醫學文本進ChatGPT後，ChatGPT就可以回答醫學的問題，甚至通過醫師國考。但我們若是要專注在醫學領域，就必須在取得各部門的同意後集成整合的資料，當這個規模變大的時候，政策以及資料的相容性都會是一大挑戰。有一些方式是該模型的聊天機器人可以集中部署在計算集群上以降低需求，如部署在DALL-E或是GPT-3。但若不是一般的聊天機器人，其他的模型就必須要部署在醫院內部以供醫師隨時運用，這個時候就需要考慮knowledge distillation的技術(圖二)，將大模型壓縮為更小模型，方便本地部署。\n圖二 結論 GMAI將成為醫療革命的催化劑，它就像一位全能的「數位醫生」，能輕鬆解析多種醫療數據，快速學會新任務，適應不同場景，不論是在傳統診室中輔助醫生診斷，還是在偏遠地區的智能設備上提供健康指導。它不僅能幫助醫生減輕繁瑣的文書負擔，讓他們有更多時間專注於患者，還能打破地域與語言的限制，讓高品質的醫療普及到每一個角落。然而，這樣的「超級醫生」也面臨隱私保護、數據收集和高計算成本等挑戰，但只要跨越這些障礙，GMAI將徹底改變我們看待和實現醫療的方式，讓醫療更有效率與更人性化。\n","date":1732492800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1732492800,"objectID":"ee1c402e296fe6de078e0dd4eaf515df","permalink":"http://localhost:56953/post/paperr2/","publishdate":"2024-11-25T00:00:00Z","relpermalink":"/post/paperr2/","section":"post","summary":"","tags":["foundation model","artificial intelligence","medicine"],"title":"基礎模型於醫學領域的運用？","type":"post"},{"authors":["戴揚紘",""],"categories":["數據科學"],"content":"Quick look 主成分分析（Principal component analysis, PCA）是一種強大且直觀的數據降維技術，被廣泛應用於臨床研究與醫學數據分析中。作為醫師，在日常工作中，我們經常面對大量的病患數據，例如基因表達數據、影像數據、實驗室檢驗值等。PCA能夠幫助我們提取數據的關鍵特徵，將高維度的資料轉換成易於解釋的低維度數據，從而揭示潛在的生物學意義。\n想要瞭接基本概念，可以看StatQuest的影片 想快速了解數學概念的，可以看李政軒老師的影片 主成分分析的數學基礎 核心思想 PCA的目的是將高維數據投影到一組新的互相正交的坐標軸上（稱為主成分），這些軸的排列方式使得：\n第一個主成分最大程度地捕捉數據的變異性； 第二個主成分捕捉剩餘變異性，且與第一主成分正交，依此類推。 也就是在一堆雜亂的數據中，找到變異程度最大的主軸來最大程度的代表這群資料，接著PCA會逐步找到與這些主軸正交的其他軸，這些軸共同構成一組新的坐標系。而所有原始數據的值都會重新投影到新的軸上。每個空間中的數據點可以被所有主成分線性加成的方式來還原原始數據。整個過程可以大致簡化成如下的公式：\n$$ S = C_{\\text{mean}} + t_1C_1 + t_2C_2 + \\dots \\text{(t:主成分權重; C:主成分)} $$ PCA的目的 我自己在分析基因數據的時候也很常用到PCA，甚至有些R bioconductor package也將PCA當成是標準前處理過程，但其實一開始都會思考，目前有其他降維工具，為何PCA還是很多人用？關於PCA的目的，初略有以下三點：\n利用降維，去除高關聯性多餘的維度 利用視覺化在2維的座標上，發現離群值或異常值 跟隨最大離散程度的軸向，保留原始訊息 由此可見，PCA可以幫助在目前動則維度數百的資料集中，還能用視覺化分析主要數據，並且評估哪些特徵維度不具有分群的效果，而可以考慮刪除或用其他方式過濾。\n數學過程 整個過程概念是先找到空間中數據點的平均值x-mean，即數據的中心點，然後以x-mean為原點，尋找通過此點的一個方向向量e，對於所有數據點xi，計算他們相對於x-mean的差值，並將這些差值投影到方向e上，在e方向上的投影值的總變異性(即投影值平方的總和)如果達到最大值，則e為第一主成分。 這邊的e為長度為1的單位向量，也就是需要經過正規化(normalization)處理，此單位化向量確保了比較不同方向時，投影的變異性(方差)完全由數據本身決定，而非向量的長度。\n所有數據點投影後的長度可以表達為：\n$$ \\ e^T (\\ x_1 - \\bar{x}), e^T (\\ x_2 - \\bar{x}), \\dots, e^T (\\ x_n - \\bar{x}) \\ $$ 而在e上的數據變異度為：\n$$ \\ \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n \\left( e^T (\\ x_i - \\bar{x}) - 0 \\right)^2 \\ $$ 接下來把上面的公式拆開： 平方公式可以看成兩個相同的元素相乘。\n$$ \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^{n} \\left(e^T (x_i - \\bar{x}) \\right)^2 = \\frac{1}{n} \\sum_{i=1}^{n} \\left(e^T (x_i - \\bar{x}) \\right) \\left(e^T (x_i - \\bar{x}) \\right)^T $$ 然而拆開為兩個矩陣，若要達到可以相乘的目的，後面的矩陣我們需要將其轉置。這邊我們回憶一下: $$ (AB)^T=B^TA^T $$ 所以上面的公式可以變換成:\n$$ \\frac{1}{n} \\sum_{i=1}^n \\left(e^T (x_i - \\bar{x})\\right) \\left((x_i - \\bar{x})^T e\\right) $$ $$ =e^T \\left( \\frac{1}{n} \\sum_{i=1}^n (x_i - \\bar{x})(x_i - \\bar{x})^T \\right) e = e^T \\Sigma e $$ 到這邊我們已經可以發現，中間大框框包圍著的部分其實就是共變異矩陣(covariance matrix)！ 到此，我們已經可以看出來PCA要解的其實就是共變異矩陣。 接下來我們要找到離散程度最大值出現的方向e1: $$ e_1 = \\arg\\max_{e} e^T \\Sigma e, \\quad e^T e = 1 $$\n這個算式若要求解，需要利用Lagrange function來針對約束條件來優化: $$ f(e, \\lambda) = e^T \\Sigma e + \\lambda (1 - e^T e) $$ 分別對參數進行偏微分後，得到： $$ \\frac{\\partial f}{\\partial e} = 2\\Sigma e - 2\\lambda e = 0 \\implies \\Sigma e = \\lambda e $$ 及 $$ \\frac{\\partial f}{\\partial \\lambda} = 1 - e^T e = 0 \\implies e^T e = 1 $$\n到此，線代魔王eigenvalue現身了，搞了那麼久，PCA原來是要我們解eigenvalue problem!! 而不要忘記了，針對對稱矩陣，eigenvalue都有實數解，所以這邊必定能找到eigenvector，也就是eigenvalue對應的方向向量。 接下來我們只要做簡單的移項，就不難發現，我們要求解最大離散程度的e1，就是eigenvalue最大值的地方! $$ \\lambda = e^T \\Sigma e $$ 而第二主軸也可以依據Lagrange function來求解，但解完偏微分之後會發現，不管是接下來的哪個次主軸，解的都是跟原來的公式一模一樣，所以我們只要求第二大的eigenvalue以及其對應的相向即可!\n實際運用 古人云：千言萬語不如一行code，我們來直接用R來玩玩看PCA是怎麼達成並且視覺化的。\n#加載數據 set.seed(123) data \u0026lt;- matrix(rnorm(100 * 3, mean = 5, sd = 2), ncol = 3) colnames(data) \u0026lt;- c(\u0026#34;Feature1\u0026#34;, \u0026#34;Feature2\u0026#34;, \u0026#34;Feature3\u0026#34;) #標準化數據，將數據移到中心 scaled_data \u0026lt;- scale(data, center = TRUE, scale = TRUE) #計算共變異矩陣 cov_matrix \u0026lt;- cov(scaled_data) #計算共變異矩陣的特徵值和特徵向量 eigen_result \u0026lt;- eigen(cov_matrix) eigenvalues \u0026lt;- eigen_result$values 出來的eigen vectors:\n[,1] [,2] [,3] [1,] 0.6733474 -0.1690336 0.7197436 [2,] -0.3533758 -0.9286934 0.1124905 [3,] -0.6494065 0.3300852 0.6850657 而eigenvalues: [1] 1.1505778 [2] 0.9801158 [3] 0.8693063\n此時我們試著使用R中的prcomp來直接操作PCA:\n#使用prcomp進行 PCA pca_result \u0026lt;- prcomp(data, center = TRUE, scale. = TRUE) 接著來同樣取出eigenvalues，看看是不是跟上面的一樣\n#取出eigenvalues prcomp用奇異值來解PCA，奇異值的平方就等於特徵值 prcomp_eigenvalues \u0026lt;- pca_result$sdev^2 prcomp_eigenvalues 出來的eigenvalues: [1] 1.1505778 [2] 0.9801158 [3] 0.8693063 跟上面操作的方式結果一至！\nPCA的視覺化 接者我可以簡單的用ggfortify套件來查看PCA的結果。\nlibrary(ggfortify) autoplot(pca_result, data = as.data.frame(data), colour = \u0026#39;Feature1\u0026#39;) + ggtitle(\u0026#34;PCA Projection\u0026#34;) + theme_minimal() PCA visualization 因為這個數據是隨機的，如果使用癌症基因數據，搭配一些顯著的臨床因子，視覺化後的分群應該會更漂亮。\n結論 主成分分析是一項將複雜數據轉化為清晰結構的強大工具，就像一個數據的解碼器，幫助我們從看似混亂的數據中提煉出最重要的線索。透過數學的魔力，我們不僅能找到數據中最大變異的方向，還能有效地降維並視覺化，讓原本高維的「迷霧森林」變成清晰的「航路圖」。\n在實際應用中，PCA不僅僅是一個數學公式，更是一種數據理解的思維方式。無論是在基因表達分析、醫學影像數據，還是多維臨床檢驗指標的綜合解讀中，PCA都能扮演一個「數據導航員」的角色，引領我們找到關鍵特徵，解決臨床問題，甚至發現潛在的生物學機制。\n當然PCA也有其缺點:\n解釋性不足: PCA的主成分是數學上計算出的線性組合，雖然能有效地捕捉數據的變異性，但每個主成分的實際意義通常不直觀，難以直接對應到具體的物理或生物學意義。例如，在醫學數據中，第一主成分可能代表數個臨床指標的綜合作用，但無法具體指出是哪一個指標在起主導作用。 假設數據線性: PCA基於線性代數方法，假設數據之間的關係是線性的。然而，在很多實際問題中（如基因調控網絡、非線性動力學模型等），數據之間的關係可能是高度非線性的，這會導致PCA無法有效捕捉數據的真實結構。 對數據尺度敏感: 如果數據的尺度(scale)差異很大，PCA的結果會嚴重受到影響。例如，一個變數的數值範圍是0-1，而另一個變數範圍是1-1000，後者會在主成分計算中占據主導地位。因此，PCA通常需要在降維前對數據進行標準化（Standardization），否則結果可能不準確。 對離群值敏感: PCA對於數據中的離群值(outliers)非常敏感，這是因為離群值會極大地影響共變異矩陣的計算，進而改變主成分的方向。如果數據中存在明顯的離群值，PCA的結果可能會失真，導致降維效果變差。 無法處理稀疏性問題: 在處理高維度但稀疏的數據（如基因表達數據或文本數據）時，PCA可能不是最佳選擇。這是因為PCA的降維過程會壓縮所有特徵的信息，導致稀疏結構丟失，無法保留某些特徵的稀疏性。 依賴均值與共變異: PCA基於數據的均值和共變異矩陣，假設數據的主要信息可以用這些統計量來描述。如果數據的分佈偏離高斯分佈或共變異矩陣無法很好地捕捉數據結構，PCA的效果可能會受到限制。 僅考慮變異性，無法考慮分類信息: PCA僅最大化數據的變異性，並不考慮下游任務(如分類或聚類)的需求。因此，如果主要目的是分類或分群，PCA降維後的特徵可能無法有效提高模型的性能。 在實際使用時，需要結合數據特性、應用場景以及模型需求，選擇適合的降維方法，必要時可考慮其他技術（如t-SNE、UMAP或LDA）作為替代或輔助方法。\n","date":1732492800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1732492800,"objectID":"2d087ae03fe15e85f6154a4a26585379","permalink":"http://localhost:56953/post/data_pca/","publishdate":"2024-11-25T00:00:00Z","relpermalink":"/post/data_pca/","section":"post","summary":"","tags":["data science","diemensionality reduction","visualization"],"title":"數據科學技術盤點:主成分分析？","type":"post"},{"authors":["戴揚紘",""],"categories":["免疫治療"],"content":"Quick look 這篇文章研究了Immune checkpoint inhibitor（ICI）療法在黑色素瘤中(melanoma)的抗藥性機制。通過分析來自患者的短期腫瘤細胞系(short term cell line))和匹配的腫瘤樣本，作者發現了三種不同的抗藥性機制，分別涉及抗原表達的喪失、抗原呈現的破壞，以及與PTEN缺失相關的免疫細胞排斥。這些抗藥性機制揭示了可能的救援性治療策略，例如恢復MHC的表達、促進先天免疫反應、以及重新刺激抗原的呈現。\n簡介 免疫檢查點抑制劑（ICI）針對PD-1的療法已徹底改變了轉移性黑色素瘤患者的治療方式。在許多III期臨床試驗中（如CheckMate-067和KEYNOTE-006），PD-1抑制劑顯示了42-45%的客觀反應率，以及6.5年42%的總體存活率。然而，約有55%的黑色素瘤患者對單獨的PD-1抑制劑療法存在先天性抗藥性，並且幾乎25%的患者在治療初期有反應，但在兩年內產生了抗藥性。因此，抗藥性問題仍然是ICI療法的一個重大挑戰。本研究通過全面分析黑色素瘤中對ICI的抗藥性機制，試圖探索這些ICI治療失敗的因素。\n為此，研究人員針對18名接受PD-1 抑制劑並且病程仍然持續進展的第四期黑色素瘤患者(9名PD-1抑制劑;9名PD-1抑制劑+CTLA4 抑制劑)進行切片，建立了22株短期腫瘤細胞系和匹配的腫瘤樣本，通過基因組、轉錄組和流式細胞儀的分析方法，探討抗藥性的產生機制。他們總結出了三個主要的抗藥性機制：抗原表達的喪失、抗原呈現的破壞和免疫細胞排斥，這些機制或許可能為治療提供新的想法。\n研究結果 抗原表達消失了？ 因為約有4-10%對PD-1抑制劑有抗藥性的黑色素瘤具有IFNγ(干擾素γ)功能的喪失，因此研究團隊以IFNγ的刺激來當切入點，結果發現，在22株細胞係接受IFNγ(1000 U/ml IFNγ，24小時)後，只有一株細胞(SCC16-0016)沒有反應，究其原因發現此細胞株之JAK2及INSL6基因有出現缺失或是融合的現象，AK2的缺失影響到MHC-I和MHC-II分子的表達，這是因為JAK2在IFNγ信號中負責STAT1(信號轉導和轉錄活化因子1)的磷酸化，進而促使MHC的表達。JAK2缺失導致了STAT1無法被磷酸化，而這樣的缺陷導致這株細胞在接受IFNγ後無法正常表現MHC-I、MHC-II、PD-L1、PD-L2，也沒有出現細胞增殖趨緩的特徵，表示這條路徑影響到了此細胞株該有的免疫反應。而在短暫植入wild-type JAK2後，SCC16-0016得以順利在IFNγ刺激後表達MHC-I。\n而在剩下的21株細胞中，有6株細胞具有內源性IFNγ表現，而這種內源性的IFNγ是也被發現與黑色素瘤去分化(de-differentiated)有關(MITF與SOX10表現下降以及melanoma-specific antigen， Melan-A的喪失)(圖 1)。這種去分化的過程使腫瘤細胞喪失了wild-type抗原的表達能力，從而減少了腫瘤細胞的免疫原性(immunogenicty)，也削弱了腫瘤對免疫系統的可見性(visibility)。 圖一 內源性IFNγ造就免疫抑制的腫瘤微環境？ 雖然具有內源性IFNγ的細胞株也會表達較高與其調控相關的基因如IRF1/9、LGALS9與MHC-I，然而在細胞激素(cytokine/chemokine)分析時發現，這些細胞因為處於去分化的狀態，分泌的細胞激素與那些處於分化態的細胞在接受IFNγ刺激後不同，說明了不同細胞狀態在誘導免疫反應的複雜性。\n這些具有內源性IFNγ的細胞會對腫瘤微環境造成什麼影響呢？團隊接著利用多參數流式細胞分析發現，與此類細胞株配對之腫瘤具有較少的CD45+細胞含量與相對較高的巨噬細胞數量，同時也發現這類腫瘤有較少的活性CD8+ T細胞。\n另外針對SCC16-0016細胞株的配對腫瘤(JAK2 mutaant)分析後也發現，跟其他細胞株的配對腫瘤相比，SCC16-0016細胞株的配對腫瘤具有最高的NK細胞比例，這個發現也驗證了NK細胞會在第一防線時針對MHC-I陰性的癌細胞做攻擊的現象，也就是所謂的missing self recognistion。\n抗原呈現遭到抑制？ 因為這些去分化的腫瘤內表現抗原的程度較低，導致腫瘤內含有較少的活性CD8+ T細胞(透過分析表面標誌來確定如PD1++Tbet+)，為了證實這個現象並非只是同步發現的結果，團隊針對兩株去分化細胞株加載了HLA-A02載體後，以melan-A peptide來刺激，結果發現在共同培養的環境下，可以誘導CD8+ T細胞的活化(IFNγ+CD107+)(圖二)，表示植入的wild-type抗原有辦法增加免疫細胞的抗腫瘤能力。然而即便是植入抗原，仍然無法逆轉細胞型態成分化狀態。 圖二 複雜的機制，讓抗原的表現消失？ 除了抗原表達的喪失外，研究還發現了一系列影響抗原呈現的獨立機制，這些機制也會導致免疫檢查點抑制劑的抗藥性。其中一個重要的機制是B2M基因的功能喪失突變。團隊發現有兩株細胞具有B2M轉錄片段消失的現象，並且利用全轉錄組(whole transcriptome)及全外顯組(whole exome)分析確認了exon 1 deletion及frameshift mutation。B2M是MHC-I複合體的重要組成部分(圖三)，當B2M基因出現突變時，MHC-I的組裝和細胞表面表達均會受到影響，從而降低腫瘤細胞被T細胞識別的可能性。 圖三 此外，CIITA(MHC-II轉錄調控因子)基因的表達沉默也是一個關鍵因素。CIITA是控制MHC-II表達的核心轉錄因子，在具有B2M基因變異的細胞株中，若該基因被表觀遺傳機制（如DNA甲基化或組蛋白去乙醯化）抑制時，MHC-II的表達將顯著降低，進而影響抗原呈現。研究中通過表觀遺傳抑制劑（如HDAC抑制劑）恢復CIITA的表達，結果顯示MHC-II的表達可以部分恢復，這表明表觀遺傳調控在抗原呈遞中的重要性。這些結果告訴我們，造成黑色素瘤抗原消失的原因不只有IFNγ訊息路徑的問題，也有其他複雜的因素共同作用。\n免疫細胞排斥？ PTEN基因的缺失與腫瘤中的免疫細胞排斥有著密切的關聯。PTEN是一個腫瘤抑制基因，其缺失會導致腫瘤細胞分泌更多的免疫抑制性分子，如TGF-β等，從而阻礙免疫細胞（尤其是CD8+ T細胞）進入腫瘤微環境。在研究中，PTEN缺失的黑色素瘤顯示出更低的CD8+ T細胞浸潤，並且在腫瘤微環境中存在更高比例的巨噬細胞，這些巨噬細胞通常具有免疫抑制的功能，進一步降低了腫瘤對免疫治療的反應。\nPTEN缺失的黑色素瘤還與腦轉移有關。研究發現，腦轉移腫瘤中PTEN缺失的比例較高，這些腫瘤不僅缺乏CD8+ T細胞的浸潤，還顯示出較高的調節性T細胞（Tregs）和suppressive myeloid細胞含量，這些免疫細胞的存在進一步加劇了腫瘤的免疫抑制狀態，使ICI療法難以奏效。\n探討 本研究結果顯示，黑色素瘤對免疫檢查點抑制劑的抗藥性主要涉及三大方面：抗原表達的喪失、抗原呈現的破壞以及免疫細胞排斥。抗原表達喪失與腫瘤細胞的去分化和內源性的IFNγ訊號有關，這些機制共同降低了腫瘤細胞的免疫抗原性，並使其難以被T細胞識別。抗原呈現的破壞則主要涉及MHC-I和MHC-II的異常，這些異常通常由基因突變或表觀遺傳調控引起。而PTEN的缺失則通過影響腫瘤微環境，抑制了免疫細胞的浸潤和活性，進一步促進了腫瘤的免疫逃脫。\n根據這些發現，研究者提出了一些潛在的治療救援策略。例如，對於抗原呈現異常的腫瘤，可以通過表觀遺傳調控劑（如HDAC抑制劑）恢復MHC表達，從而增強免疫系統對腫瘤的識別。此外，對於因PTEN缺失而造成免疫細胞排斥的腫瘤，可以考慮使用刺激先天免疫系統的療法，如Toll樣受體激動劑，來增強腫瘤微環境中的免疫活性。\n去分化的黑色素瘤則更具挑戰性，因為這些腫瘤通常表現出較高的抗藥性和免疫逃脫能力。研究者建議，結合免疫療法與促進鐵依賴性氧化壓力的藥物（如鐵死亡誘導劑），可能有助於改善免疫檢查點抑制劑的療效，因為先前研究發現去分化的黑色素瘤對鐵死亡誘導劑具有一定的敏感度。此外，針對腫瘤微環境中的免疫抑制因素，如Tregs和免疫抑制性巨噬細胞，也應該考慮相應的干預措施，以減少這些細胞對抗腫瘤免疫反應的負面影響。\n這項研究為理解黑色素瘤的免疫檢查點抑制劑抗藥性提供了重要的分子和功能線索，並為未來的治療策略提供了方向。通過精準識別不同的抗藥性機制，並針對性地進行治療，我們有望改善黑色素瘤患者的治療效果，特別是對於那些對現有免疫療法無反應的患者。這些新策略的探索與應用，將可能為免疫治療的救援治療開創新的局面。\n","date":1732320000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1732320000,"objectID":"49fe625e1d51a29699b058a7f7aaa116","permalink":"http://localhost:56953/post/paperr1/","publishdate":"2024-11-23T00:00:00Z","relpermalink":"/post/paperr1/","section":"post","summary":"","tags":["immunotherapy","melanoma","cancer","resistance mechanism"],"title":"黑色素瘤如何對免疫治療產生抗藥性？","type":"post"},{"authors":["戴揚紘","李定頡"],"categories":null,"content":"Title A Meta-Analysis and Meta-Regression of the Efficacy, Toxicity, and Quality of Life Outcomes Following Prostate-Specific Membrane Antigen Radioligand Therapy Utilising Lutetium-177 and Actinium- 225 in Metastatic Prostate Cancer\nAbstract Background and objective: Management of metastatic prostate cancer (mPCa) presents significant challenges. In this systematic review, meta-analysis, and meta-regression, the efficacy, safety, and quality of life (QoL) outcomes of prostate-specific membrane antigen (PSMA)-targeted radioligand therapy (PRLT) utilising lutetium-177 ([177Lu]Lu-PSMA) and actinium-225 ([225Ac]Ac-PSMA) were assessed.\nMethods: A detailed literature search across PubMed/Medline, EMBASE, Web of Science, Scopus, and Cochrane Library was conducted, culminating in the inclusion of 100 studies involving 8711 patients. Data on prostate-specific antigen (PSA) responses, toxicity profiles, and QoL and survival outcomes were analysed. Proportional meta-analyses and meta-regression analyses were performed.\nKey findings and limitations: The estimated proportion of patients with PSA decline ≥50% was 0.49 for [177Lu]Lu-PSMA and 0.60 for [225Ac]Ac-PSMA in mPCa, particularly metastatic castration-resistant prostate cancer. A meta-regression analysis indicated an association between the cumulative amount of administered activity and the proportion of PSA ≥50% decline. Positive PSA responses were observed alongside improved overall survival across both therapies. Our analyses also identified the key factors associated with PSA responses and survival outcomes, including baseline haemoglobin level, and the presence of visceral metastases. Although anaemia was commonly observed, with [177Lu]Lu-PSMA, severe toxicities were infrequent. Improved QoL was observed following [177Lu]Lu-PSMA therapy, whereas it remained stable following the second cycle of [225Ac]Ac-PSMA treatment. Heterogeneity across studies for PSA responses and toxicity profiles is a limitation.\nConclusions and clinical implications: Our findings suggest an association between PRLT and reductions in PSA levels, as well as associations with enhanced survival outcomes in mPCa. Furthermore, our analysis shows a low incidence of severe toxicity associated with this treatment. These observations highlight the important role of PRLT in the management of mPCa.\n","date":1726012800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1726012800,"objectID":"2365e8bcd70b63cb5650e9b60760a109","permalink":"http://localhost:56953/event/meta_publish/","publishdate":"2024-09-11T00:00:00Z","relpermalink":"/event/meta_publish/","section":"event","summary":"A Meta-Analysis and Meta-Regression of the Efficacy, Toxicity, and Quality of Life Outcomes Following Prostate-Specific Membrane Antigen Radioligand Therapy Utilising Lutetium-177 and Actinium- 225 in Metastatic Prostate Cancer","tags":[],"title":"新文章發表於 European Urology","type":"event"},{"authors":["戴揚紘","沈伯鍵"],"categories":null,"content":"Title DriverOmicsNet-An Integrated Graph Convolutional Network for Multi-Omics Exploration of Cancer Driver Genes\nAbstract Background: Cancer is a complex and heterogeneous group of diseases driven by genetic mutations and molecular changes. Identifying and characterizing cancer driver genes (CDgs) is crucial for understanding cancer biology and guiding precision oncology. Integrating multi-omics data can reveal the intricate molecular interactions underlying cancer progression and treatment responses.\nMethods: We developed a graph convolutional network (GCN) framework, DriverOmicsNet, that integrates multi-omics data using STRING protein-protein interaction (PPI) networks and correlation-based weighted correlation network analysis (WGCNA). We applied this framework to 15 cancer types, analyzing 5555 tumor samples to predict cancer-related features such as homologous recombination deficiency (HRD), cancer stemness, immune clusters, tumor stage, and survival outcomes.\nFindings: DriverOmicsNet demonstrated superior predictive accuracy and model performance metrics across all target labels when compared with GCN models based on STRING network alone. Gene expression emerged as the most significant feature, reflecting the dynamic and functional state of cancer cells. The combined use of STRING PPI and WGCNA networks enhanced the identification of key driver genes and their interactions.\nInterpretation: Our study highlights the effectiveness of using GCNs to integrate multi-omics data for precision oncology. The integration of STRING PPI and WGCNA networks provides a comprehensive framework that improves predictive power and facilitates the understanding of cancer biology, paving the way for more tailored treatments.\n","date":1721520000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1721520000,"objectID":"110d6affe7a35b480457157a4351d2fb","permalink":"http://localhost:56953/event/driveromics/","publishdate":"2024-07-21T00:00:00Z","relpermalink":"/event/driveromics/","section":"event","summary":"DriverOmicsNet-An Integrated Graph Convolutional Network for Multi-Omics Exploration of Cancer Driver Genes","tags":[],"title":"新 Preprint 發表於 biorxiv","type":"event"},{"authors":["李定頡"],"categories":null,"content":" ","date":1707264000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1707264000,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"http://localhost:56953/event/example/","publishdate":"2024-02-07T00:00:00Z","relpermalink":"/event/example/","section":"event","summary":"腎臟科國考複習","tags":[],"title":"腎臟科國考複習","type":"event"},{"authors":["戴揚紘","李定頡"],"categories":null,"content":"Title Incorporating knowledge of disease-defining hub genes and regulatory network into a machine learning-based model for predicting treatment response in lupus nephritis after the first renal flare\nAbstract Background:Identifying candidates responsive to treatment is important in lupus nephritis (LN) at the renal flare (RF) because an effective treatment can lower the risk of progression to end-stage kidney disease. However, machine learning (ML)-based models that address this issue are lacking.\nMethods:Transcriptomic profiles based on DNA microarray data were extracted from the GSE32591 and GSE112943 datasets. Comprehensive bioinformatics analyses were performed to identify disease-defining genes (DDGs). Peripheral blood samples (GSE81622, GSE99967, and GSE72326) were used to evaluate the effect of DDGs. Single-sample gene set enrichment analysis (ssGSEA) scores of the DDGs were calculated and correlated with specific immunology genes listed in the nCounter panel. GSE60681 and GSE69438 were used to examine the ability of the DDGs to discriminate LN from other renal diseases. K-means clustering was used to obtain the separate gene sets. The clustering results were extended to data derived using the nCounter technique. The least absolute shrinkage and selection operator (LASSO) algorithm was used to identify genes with high predictive value for treatment response after the first RF in each cluster. LASSO models with tenfold validation were built in GSE200306 and assessed by receiver operating characteristic (ROC) analysis with area under curve (AUC). The models were validated by using an independent dataset (GSE113342).\nResults:Forty-five hub genes specific to LN were identified. Eight optimal disease-defining clusters (DDCs) were identified in this study. Th1 and Th2 cell differentiation pathway was significantly enriched in DDC-6. LCK in DDC-6, whose expression positively correlated with various subsets of T cell infiltrations, was found to be differentially expressed between responders and non-responders and was ranked high in regulatory network analysis. Based on DDC-6, the prediction model had the best performance (AUC: 0.75; 95% confidence interval: 0.44–1 in the testing set) and high precision (0.83), recall (0.71), and F1 score (0.77) in the validation dataset.\nConclusions:Our study demonstrates that incorporating knowledge of biological phenotypes into the ML model is feasible for evaluating treatment response after the first RF in LN. This knowledge-based incorporation improves the model’s transparency and performance. In addition, LCK may serve as a biomarker for T-cell infiltration and a therapeutic target in LN.\n","date":1675382400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1675382400,"objectID":"25714840091c63a9e8af4d3b09595b5b","permalink":"http://localhost:56953/event/lupus/","publishdate":"2023-02-03T00:00:00Z","relpermalink":"/event/lupus/","section":"event","summary":"Incorporating knowledge of disease-defining hub genes and regulatory network into a machine learning-based model for predicting treatment response in lupus nephritis after the first renal flare","tags":[],"title":"新文章發表於Journal of Translational Medicine","type":"event"},{"authors":null,"categories":null,"content":"","date":1666569600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1666569600,"objectID":"6d99026b9e19e4fa43d5aadf147c7176","permalink":"http://localhost:56953/contact/","publishdate":"2022-10-24T00:00:00Z","relpermalink":"/contact/","section":"","summary":"","tags":null,"title":"Contact","type":"landing"},{"authors":null,"categories":null,"content":"","date":1666569600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1666569600,"objectID":"c1d17ff2b20dca0ad6653a3161942b64","permalink":"http://localhost:56953/people/","publishdate":"2022-10-24T00:00:00Z","relpermalink":"/people/","section":"","summary":"","tags":null,"title":"People","type":"landing"},{"authors":null,"categories":null,"content":"","date":1666569600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1666569600,"objectID":"b0d61e5cbb7472bf320bf0ef2aaeb977","permalink":"http://localhost:56953/tour/","publishdate":"2022-10-24T00:00:00Z","relpermalink":"/tour/","section":"","summary":"","tags":null,"title":"Tour","type":"landing"},{"authors":["admin"],"categories":null,"content":" Create your slides in Markdown - click the Slides button to check out the example. Add the publication’s full text or supplementary notes here. You can use rich formatting such as including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"http://localhost:56953/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[null],"title":"An example preprint / working paper","type":"publication"},{"authors":["admin","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Add the publication’s full text or supplementary notes here. You can use rich formatting such as including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"http://localhost:56953/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[null],"title":"An example journal article","type":"publication"},{"authors":["admin","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Add the publication’s full text or supplementary notes here. You can use rich formatting such as including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"http://localhost:56953/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[],"title":"An example conference paper","type":"publication"}]